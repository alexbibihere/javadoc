{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{450:function(e,n,t){\"use strict\";t.r(n);var a=t(2),i=Object(a.a)({},(function(){var e=this,n=e._self._c;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[n(\"h1\",{attrs:{id:\"java-基础必读源码\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java-基础必读源码\"}},[e._v(\"#\")]),e._v(\" java 基础必读源码\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"object\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#object\"}},[e._v(\"#\")]),e._v(\" Object\")]),e._v(\" \"),n(\"p\",[e._v(\"getClass()返回对象的运行时类的 Class 对象,可以用于反射操作。\\n//\"),n(\"code\",[e._v(\"native\")]),e._v('修饰的方法，调用系统方法，通常由C++或C语言实现\\npublic final native Class<?> getClass();\\nhashCode()返回对象的哈希码，用于在哈希表中定位对象\\n@HotSpotIntrinsicCandidate\\npublic native int hashCode();\\nequals()比较两个对象的相等性。默认实现比较两个对象的内存地址\\npublic boolean equals(Object obj) {\\nreturn (this == obj);\\n}\\nclone()创建并返回当前对象的一个副本,必须实现 Cloneable 接口.\\nprotected native Object clone() throws CloneNotSupportedException;\\ntoString()返回对象的字符串表示，默认实现为类名加哈希码\\npublic String toString() {\\nreturn getClass().getName() + \"@\" + Integer.toHexString(hashCode());\\n}\\nnotify()唤醒在此对象监视器上等待的单个线程,用于多线程编程。\\n@HotSpotIntrinsicCandidate\\npublic final native void notify();\\nnotifyAll()唤醒在此对象监视器上等待的所有线程，用于多线程编程。\\nwait()使当前线程在此对象监视器上等待，直到其他线程调用 notify() 或 notifyAll()。有多个重载版本，可以指定等待的时间。\\n@HotSpotIntrinsicCandidate\\npublic final native void notifyAll();\\nfinalize()当对象的引用不再被使用且被垃圾回收器标记为可回收时，finalize() 方法会被调用,从 JDK 9 开始，finalize() 方法不推荐使用。\\nprotected void finalize() throws Throwable { }')]),e._v(\" \"),n(\"h2\",{attrs:{id:\"integer\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#integer\"}},[e._v(\"#\")]),e._v(\" Integer\")]),e._v(\" \"),n(\"p\",[e._v(\"内部类IntegerCache，缓存范围 -128 到127 ，最大值可配置\\nprivate static class IntegerCache {\\nstatic final int low = -128;\\nstatic final int high;\\nstatic final Integer cache[];\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",[n(\"code\",[e._v('static {\\n    // high value may be configured by property\\n    int h = 127;\\n    String integerCacheHighPropValue =\\n        VM.getSavedProperty(\"java.lang.Integer.IntegerCache.high\");\\n    if (integerCacheHighPropValue != null) {\\n        try {\\n            int i = parseInt(integerCacheHighPropValue);\\n            i = Math.max(i, 127);\\n            // Maximum array size is Integer.MAX_VALUE\\n            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);\\n        } catch( NumberFormatException nfe) {\\n            // If the property cannot be parsed into an int, ignore it.\\n        }\\n    }\\n    high = h;\\n\\n    cache = new Integer[(high - low) + 1];\\n    int j = low;\\n    for(int k = 0; k < cache.length; k++)\\n        cache[k] = new Integer(j++);\\n\\n    // range [-128, 127] must be interned (JLS7 5.1.7)\\n    assert IntegerCache.high >= 127;\\n}\\n\\nprivate IntegerCache() {}\\n')])])]),n(\"p\",[e._v(\"}\\nvalueOf 方法,整数在缓存范围中直接返回缓存的Integer\\n@HotSpotIntrinsicCandidate\\npublic static Integer valueOf(int i) {\\nif (i >= IntegerCache.low && i <= IntegerCache.high)\\nreturn IntegerCache.cache[i + (-IntegerCache.low)];\\nreturn new Integer(i);\\n}\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"string\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#string\"}},[e._v(\"#\")]),e._v(\" String\")]),e._v(\" \"),n(\"p\",[e._v(\"类用final修饰、value值是1.8版本及以前是char[]数组，1.9之后是byte[]也是用final进行修饰\\npublic final class String\\nimplements java.io.Serializable, Comparable\"),n(\"String\",[e._v(\", CharSequence {\")])],1),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",[n(\"code\",[e._v(\"/**\\n * 存储字符的字节\\n */\\n@Stable\\nprivate final byte[] value;\\n//字符编码\\nprivate final byte coder;\\n\\n/** Cache the hash code for the string */\\nprivate int hash; // Default to 0\\n\")])])]),n(\"h2\",{attrs:{id:\"hashmap\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hashmap\"}},[e._v(\"#\")]),e._v(\" HashMap\")]),e._v(\" \"),n(\"ol\",[n(\"li\",[e._v(\"HashMap 的基本结构\\nHashMap 的主要数据结构是数组和链表（或红黑树）：\")])]),e._v(\" \"),n(\"p\",[e._v(\"Node[] table: 存储哈希表的数组，每个元素是一个链表或红黑树的头节点。\\nint size: 当前映射中键值对的数量。\\nint threshold: 用于控制扩容的阈值。当 size 超过 threshold = (capacity * load factor)时，HashMap 会进行扩容，通常是原来的两倍。\\nfloat loadFactor: 负载因子，表示哈希表的满载程度，默认值为 0.75。\")]),e._v(\" \"),n(\"p\",[e._v(\"transient Node<K,V>[] table;\")]),e._v(\" \"),n(\"p\",[e._v(\"transient Set<Map.Entry<K,V>> entrySet;\")]),e._v(\" \"),n(\"p\",[e._v(\"transient int size;\")]),e._v(\" \"),n(\"p\",[e._v(\"transient int modCount;\")]),e._v(\" \"),n(\"p\",[e._v(\"/**\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"The next size value at which to resize (capacity * load factor).\")]),e._v(\" \"),n(\"li\"),e._v(\" \"),n(\"li\",[e._v(\"@serial\\n*/\\nint threshold;\")])]),e._v(\" \"),n(\"p\",[e._v(\"final float loadFactor;\\n//节点链表\\nstatic class Node<K,V> implements Map.Entry<K,V> {\\nfinal int hash;\\nfinal K key;\\nV value;\\nNode<K,V> next;\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",[n(\"code\",[e._v(\"Node(int hash, K key, V value, Node<K,V> next) {\\n    this.hash = hash;\\n    this.key = key;\\n    this.value = value;\\n    this.next = next;\\n}\\n..............\\n\")])])]),n(\"p\",[e._v(\"}\")]),e._v(\" \"),n(\"p\",[e._v(\"//树结果\\nstatic final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {\\nTreeNode<K,V> parent;  // red-black tree links\\nTreeNode<K,V> left;\\nTreeNode<K,V> right;\\nTreeNode<K,V> prev;    // needed to unlink next upon deletion\\nboolean red;\\nTreeNode(int hash, K key, V val, Node<K,V> next) {\\nsuper(hash, key, val, next);\\n}\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",[n(\"code\",[e._v(\"/**\\n * Returns root of tree containing this node.\\n */\\nfinal TreeNode<K,V> root() {\\n    for (TreeNode<K,V> r = this, p;;) {\\n        if ((p = r.parent) == null)\\n            return r;\\n        r = p;\\n    }\\n}\\n\")])])]),n(\"p\",[e._v(\".........\\n2. 构造函数\\nHashMap 提供了多个构造函数，可以自定义初始容量和负载因子：\")]),e._v(\" \"),n(\"p\",[e._v('public HashMap(int initialCapacity, float loadFactor) {\\nif (initialCapacity < 0)\\nthrow new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity);\\nif (loadFactor <= 0 || Float.isNaN(loadFactor))\\nthrow new IllegalArgumentException(\"Illegal load factor: \" + loadFactor);\\nthis.loadFactor = loadFactor;\\nthis.threshold = tableSizeFor(initialCapacity);\\n}\\n3 tableSizeFor 方法\\n该方法用于计算最接近 initialCapacity 的 2 的幂次方，以保证 HashMap 的性能。这样做的目的是为了减少哈希冲突。')]),e._v(\" \"),n(\"p\",[e._v(\"static final int tableSizeFor(int cap) {\\nint n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);\\nreturn (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\\n}\\n4. 哈希函数\\nHashMap 使用哈希函数来计算键的哈希值，并将其映射到数组的索引。以下是哈希函数的实现：\")]),e._v(\" \"),n(\"p\",[e._v(\"static final int hash(int h) {\\nreturn h ^ (h >>> 16);\\n}\\n这个哈希函数通过位运算来混合高位和低位的哈希值，从而降低哈希碰撞的概率。\")]),e._v(\" \"),n(\"ol\",{attrs:{start:\"5\"}},[n(\"li\",[e._v(\"添加元素\\nHashMap 的核心操作之一是添加元素，主要通过 put 方法实现：\")])]),e._v(\" \"),n(\"p\",[e._v(\"public V put(K key, V value) {\\nreturn putVal(hash(key), key, value, false, true);\\n}\")]),e._v(\" \"),n(\"p\",[e._v(\"final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {\\nNode<K,V>[] tab; Node<K,V> p; int n, i;\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",[n(\"code\",[e._v(\"// 如果数组为空，则进行初始化\\nif ((tab = table) == null || (n = tab.length) == 0)\\n    n = (tab = resize()).length;\\n\\n// 计算索引\\nif ((p = tab[i = (n - 1) & hash]) == null)\\n    tab[i] = newNode(hash, key, value, null);\\nelse {\\n    Node<K,V> e; K k;\\n    if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))\\n        e = p; // 找到键值对\\n    else if (p instanceof TreeNode)\\n        e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); // 红黑树处理\\n    else {\\n        for (int binCount = 0; ; ++binCount) {\\n            if ((e = p.next) == null) {\\n                p.next = newNode(hash, key, value, null);\\n                if (binCount >= TREEIFY_THRESHOLD - 1) // 检查是否需要转化为红黑树\\n                    treeifyBin(tab, hash);\\n                break;\\n            }\\n            if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\\n                break;\\n            p = e;\\n        }\\n    }\\n    if (e != null) { // 更新值\\n        V oldValue = e.value;\\n        if (!onlyIfAbsent || oldValue == null)\\n            e.value = value;\\n        return oldValue;\\n    }\\n}\\n\\n// 增加大小并检查是否需要扩容\\nif (++size > threshold)\\n    resize();\\nreturn null;\\n\")])])]),n(\"p\",[e._v(\"}\\n6. 扩容\\n当 size 超过 threshold 时，HashMap 会自动进行扩容，通常是将数组长度翻倍，将旧数组中的所有元素重新计算哈希值，并将它们放入新的数组中。这是因为哈希表的索引是基于数组的长度计算的，当数组长度改变时，哈希值的索引也会改变。扩容过程通过 resize() 方法实现：\")]),e._v(\" \"),n(\"p\",[e._v(\"//伪代码\\nfinal Node<K,V>[] resize() {\\nNode<K,V>[] oldTab = table;\\nint oldCapacity = (oldTab == null) ? 0 : oldTab.length;\\nint newCapacity = oldCapacity << 1; // 新容量是旧容量的两倍\\nNode<K,V>[] newTab = new Node[newCapacity];\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",[n(\"code\",[e._v(\"// 将旧数组中的元素重新哈希并放入新数组\\nfor (int j = 0; j < oldCapacity; j++) {\\n    Node<K,V> e = oldTab[j];\\n    if (e != null) {\\n        oldTab[j] = null; // 释放旧数组的引用\\n        do {\\n            Node<K,V> next = e.next;\\n            int i = (newCapacity - 1) & e.hash; // 计算新索引\\n            e.next = newTab[i]; // 将元素放入新数组\\n            newTab[i] = e;\\n            e = next;\\n        } while (e != null);\\n    }\\n}\\ntable = newTab; // 更新 table 引用\\nthreshold = (int)(newCapacity * loadFactor); // 更新阈值\\n\")])])]),n(\"p\",[e._v(\"}\\n7. 查找元素\\n查找元素主要通过 get 方法实现：\")]),e._v(\" \"),n(\"p\",[e._v(\"public V get(Object key) {\\nNode<K,V> e;\\nreturn (e = getNode(hash(key), key)) == null ? null : e.value;\\n}\")]),e._v(\" \"),n(\"p\",[e._v(\"final Node<K,V> getNode(int hash, Object key) {\\nNode<K,V>[] tab; Node<K,V> e; int n; K k;\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",[n(\"code\",[e._v(\"if ((tab = table) != null && (n = tab.length) > 0) {\\n    if ((e = tab[(n - 1) & hash]) != null) {\\n        if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\\n            return e; // 找到\\n        if (e instanceof TreeNode)\\n            return ((TreeNode<K,V>)e).getTreeNode(hash, key); // 红黑树查找\\n        while (e != null) {\\n            if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\\n                return e;\\n            e = e.next; // 遍历链表\\n        }\\n    }\\n}\\nreturn null;\\n\")])])]),n(\"p\",[e._v(\"}\\n8. 删除元素\\n删除元素通过 remove 方法实现，过程与查找类似：\")]),e._v(\" \"),n(\"p\",[e._v(\"public V remove(Object key) {\\nNode<K,V> e;\\nreturn (e = removeNode(hash(key), key)) == null ? null : e.value;\\n}\")]),e._v(\" \"),n(\"p\",[e._v(\"final Node<K,V> removeNode(int hash, Object key) {\\n// 查找并删除节点的逻辑\\n}\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"arraylist\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#arraylist\"}},[e._v(\"#\")]),e._v(\" ArrayList\")]),e._v(\" \"),n(\"p\",[e._v(\"底层维护一个动态数组，初始默认容量10，通常每次扩容后的大小为原来的1.5倍\\npublic class ArrayList\"),n(\"E\",[e._v(\" extends AbstractList\"),n(\"E\",[e._v(\" implements List\"),n(\"E\",[e._v(\", RandomAccess, Cloneable, Serializable {\\nprivate transient Object[] elementData; // 存储元素的数组\\nprivate int size; // 当前元素数量\")])],1)],1)],1),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",[n(\"code\",[e._v(\"// 默认初始化容量\\nprivate static final int DEFAULT_CAPACITY = 10;\\n\")])])]),n(\"p\",[e._v(\"}\")]),e._v(\" \"),n(\"p\",[e._v(\"//扩容\\nprivate void grow(int minCapacity) {\\n// overflow-conscious code\\nint oldCapacity = elementData.length;\\n//1.5倍\\nint newCapacity = oldCapacity + (oldCapacity >> 1);\\nif (newCapacity - minCapacity < 0)\\nnewCapacity = minCapacity;\\nif (newCapacity - MAX_ARRAY_SIZE > 0)\\nnewCapacity = hugeCapacity(minCapacity);\\n// minCapacity is usually close to size, so this is a win:\\nelementData = Arrays.copyOf(elementData, newCapacity);\\n}\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"hashset\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hashset\"}},[e._v(\"#\")]),e._v(\" HashSet\")]),e._v(\" \"),n(\"p\",[e._v(\"底层维护的HashMap，元素维护在HashMap的key中\")]),e._v(\" \"),n(\"p\",[e._v(\"private transient HashMap<E,Object> map; // 底层使用 HashMap 存储元素\\nprivate static final Object PRESENT = new Object(); // 存储的值\")]),e._v(\" \"),n(\"p\",[e._v(\"//构造器\\npublic HashSet() {\\nmap = new HashMap<>();\\n}\")]),e._v(\" \"),n(\"p\",[e._v(\"// t添加的元素作为Map的key，值为 new Object\\npublic boolean add(E e) {\\nreturn map.put(e, PRESENT)==null;\\n}\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"collections\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#collections\"}},[e._v(\"#\")]),e._v(\" Collections\")]),e._v(\" \"),n(\"p\",[e._v(\"常用API\")]),e._v(\" \"),n(\"p\",[e._v(\"sort(List\"),n(\"T\",[e._v(\" list)对指定的列表进行升序排序。\\nbinarySearch(List<? extends Comparable<? super T>> list, T key)使用二分查找法在已排序的列表中查找指定元素，返回其索引。\\nsynchronizedList(List\"),n(\"T\",[e._v(\" list)将List转为线程安全的list,map等集合结构都有对应的API。 核心原理对集合进行二次封装，将集合的修改查询加synchronized修饰\\nstatic class SynchronizedList\"),n(\"E\",[e._v(\"\\nextends SynchronizedCollection\"),n(\"E\",[e._v(\"\\nimplements List\"),n(\"E\",[e._v(\" {\\nprivate static final long serialVersionUID = -7754090372962971524L;\")])],1)],1)],1)],1)],1),e._v(\" \"),n(\"p\",[e._v(\"final List\"),n(\"E\",[e._v(\" list;\")])],1),e._v(\" \"),n(\"p\",[e._v(\"SynchronizedList(List\"),n(\"E\",[e._v(\" list) {\\nsuper(list);\\nthis.list = list;\\n}\\n.............\")])],1),e._v(\" \"),n(\"p\",[e._v(\"public E get(int index) {\\nsynchronized (mutex) {return list.get(index);}\\n}\\npublic E set(int index, E element) {\\nsynchronized (mutex) {return list.set(index, element);}\\n}\\npublic void add(int index, E element) {\\nsynchronized (mutex) {list.add(index, element);}\\n}\\npublic E remove(int index) {\\nsynchronized (mutex) {return list.remove(index);}\\n}\\n................\\n}\\nunmodifiableList(List<? extends T> list)修改成不可变得集合，核心原理二次封装集合，实现集合接口，在修改接口直接抛出异常。\\nstatic class UnmodifiableList\"),n(\"E\",[e._v(\" extends UnmodifiableCollection\"),n(\"E\",[e._v(\"\\nimplements List\"),n(\"E\",[e._v(\" {\\nprivate static final long serialVersionUID = -283967356065247728L;\")])],1)],1)],1),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",[n(\"code\",[e._v(\"final List<? extends E> list;\\n\\nUnmodifiableList(List<? extends E> list) {\\n    super(list);\\n    this.list = list;\\n}\\n\\npublic boolean equals(Object o) {return o == this || list.equals(o);}\\npublic int hashCode()           {return list.hashCode();}\\n\\npublic E get(int index) {return list.get(index);}\\npublic E set(int index, E element) {\\n    throw new UnsupportedOperationException();\\n}\\npublic void add(int index, E element) {\\n    throw new UnsupportedOperationException();\\n}\\npublic E remove(int index) {\\n    throw new UnsupportedOperationException();\\n}\\n\")])])]),n(\"p\",[e._v(\"..........\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"threadlocal\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadlocal\"}},[e._v(\"#\")]),e._v(\" ThreadLocal\")]),e._v(\" \"),n(\"p\",[e._v(\"set(t)首先获取当前线程的 ThreadLocalMap，如果不存在，则调用 createMap() 创建一个新的 ThreadLocalMap,当前ThreadLocalMap引用作为key。\\npublic void set(T value) {\\nThread t = Thread.currentThread();\\nThreadLocalMap map = getMap(t);\\nif (map != null) {\\nmap.set(this, value);\\n} else {\\ncreateMap(t, value);\\n}\\n}\")]),e._v(\" \"),n(\"p\",[e._v(\"void createMap(Thread t, T firstValue) {\\nt.threadLocals = new ThreadLocalMap(this, firstValue);\\n}\")]),e._v(\" \"),n(\"p\",[e._v('get() 当前线程为key,获取ThreadLocalMap再通过TheadLocal作为可以获取值\\npublic T get() {\\nThread t = Thread.currentThread();\\nThreadLocalMap map = getMap(t);\\nif (map != null) {\\nThreadLocalMap.Entry e = map.getEntry(this);\\nif (e != null) {\\n@SuppressWarnings(\"unchecked\")\\nT result = (T)e.value;\\nreturn result;\\n}\\n}\\nreturn setInitialValue();\\n}')]),e._v(\" \"),n(\"h2\",{attrs:{id:\"executors\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#executors\"}},[e._v(\"#\")]),e._v(\" Executors\")]),e._v(\" \"),n(\"p\",[e._v(\"下面几个是默认封装好的一些线程池，比如缓存线程池、固定线程池、单线程线程池....\")]),e._v(\" \"),n(\"p\",[e._v(\"//Java 8 引入的一种线程池实现，专门用于支持工作窃取算法。该线程池适用于任务数量不确定、任务执行时间不一致的场景，能够提高 CPU 的利用率并减少任务执行的延迟。\\npublic static ExecutorService newWorkStealingPool(int parallelism) {\\nreturn new ForkJoinPool\\n(parallelism,\\nForkJoinPool.defaultForkJoinWorkerThreadFactory,\\nnull, true);\\n}\")]),e._v(\" \"),n(\"p\",[e._v(\"//固定线程池\\npublic static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {\\nreturn new ThreadPoolExecutor(nThreads, nThreads,\\n0L, TimeUnit.MILLISECONDS,\\nnew LinkedBlockingQueue\"),n(\"Runnable\",[e._v(\"(),\\nthreadFactory);\\n}\")])],1),e._v(\" \"),n(\"p\",[e._v(\"//单线程线程池\\npublic static ExecutorService newSingleThreadExecutor() {\\nreturn new FinalizableDelegatedExecutorService\\n(new ThreadPoolExecutor(1, 1,\\n0L, TimeUnit.MILLISECONDS,\\nnew LinkedBlockingQueue\"),n(\"Runnable\",[e._v(\"()));\\n}\")])],1),e._v(\" \"),n(\"p\",[e._v(\"//缓存线程池\")]),e._v(\" \"),n(\"p\",[e._v(\"public static ExecutorService newCachedThreadPool() {\\nreturn new ThreadPoolExecutor(0, Integer.MAX_VALUE,\\n60L, TimeUnit.SECONDS,\\nnew SynchronousQueue\"),n(\"Runnable\",[e._v(\"());\\n}\")])],1),e._v(\" \"),n(\"p\",[e._v(\"// 单线程定时线程池\\npublic static ScheduledExecutorService newSingleThreadScheduledExecutor() {\\nreturn new DelegatedScheduledExecutorService\\n(new ScheduledThreadPoolExecutor(1));\\n}\")]),e._v(\" \"),n(\"h2\",{attrs:{id:\"threadpoolexecutor\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#threadpoolexecutor\"}},[e._v(\"#\")]),e._v(\" ThreadPoolExecutor\")]),e._v(\" \"),n(\"ol\",[n(\"li\",[e._v(\"构造方法核心参数\\ncorePoolSize: 核心线程数，始终保持的最小线程数。\")])]),e._v(\" \"),n(\"p\",[e._v(\"maximumPoolSize: 线程池允许的最大线程数。\")]),e._v(\" \"),n(\"p\",[e._v(\"keepAliveTime: 非核心线程的存活时间。\")]),e._v(\" \"),n(\"p\",[e._v(\"workQueue: 用于存储待执行任务的队列。\")]),e._v(\" \"),n(\"p\",[e._v(\"threadFactory: 用于创建新线程的工厂。\")]),e._v(\" \"),n(\"p\",[e._v(\"handler: 当线程池无法处理新任务时的拒绝策略。\")]),e._v(\" \"),n(\"p\",[e._v(\"public ThreadPoolExecutor(int corePoolSize,\\nint maximumPoolSize,\\nlong keepAliveTime,\\nTimeUnit unit,\\nBlockingQueue\"),n(\"Runnable\",[e._v(\" workQueue,\\nThreadFactory threadFactory,\\nRejectedExecutionHandler handler) {\\nif (corePoolSize < 0 ||\\nmaximumPoolSize <= 0 ||\\nmaximumPoolSize < corePoolSize ||\\nkeepAliveTime < 0)\\nthrow new IllegalArgumentException();\\nif (workQueue == null || threadFactory == null || handler == null)\\nthrow new NullPointerException();\\nthis.corePoolSize = corePoolSize;\\nthis.maximumPoolSize = maximumPoolSize;\\nthis.workQueue = workQueue;\\nthis.keepAliveTime = unit.toNanos(keepAliveTime);\\nthis.threadFactory = threadFactory;\\nthis.handler = handler;\\n}\\n2. 拒绝策略\\nThreadPoolExecutor 提供了多种拒绝策略,当然有接口也能自定义实拒绝策略。\")])],1),e._v(\" \"),n(\"p\",[e._v(\"AbortPolicy: 默认策略，抛出异常。\\nCallerRunsPolicy: 调用者运行策略，任务由调用 execute 的线程执行。\\nDiscardPolicy: 丢弃任务，不抛出异常。\\nDiscardOldestPolicy: 丢弃队列中最旧的任务，并尝试提交新任务。\\n3.了解set方法、get方法\\n可利用get方法监听线程池状态，通过监听配置中心配置，调用set方法动态调整线程池核心参数。\")]),e._v(\" \"),n(\"p\",[e._v(\"总结\\n这些都是java开发都用过得API，对于常用的API需要了解其原理，才能抗得住面试官得拷问。希望这篇博客能帮助你加深对Java基础知识的掌握，继续学习，实践编程，你会发现Java的魅力无穷！\")])])}),[],!1,null,null,null);n.default=i.exports}}]);","extractedComments":[]}