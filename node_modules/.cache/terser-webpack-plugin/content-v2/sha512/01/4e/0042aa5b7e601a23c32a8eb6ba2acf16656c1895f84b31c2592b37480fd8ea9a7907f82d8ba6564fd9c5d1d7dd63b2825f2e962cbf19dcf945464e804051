{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{480:function(a,s,h){\"use strict\";h.r(s);var v=h(2),e=Object(v.a)({},(function(){var a=this,s=a._self._c;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[s(\"h2\",{attrs:{id:\"介绍\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#介绍\"}},[a._v(\"#\")]),a._v(\" 介绍\")]),a._v(\" \"),s(\"p\",[a._v(\"Map 是一种无序的键值对集合，其中键必须是唯一的。Map 允许通过键来快速检索值。\")]),a._v(\" \"),s(\"h2\",{attrs:{id:\"特点\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#特点\"}},[a._v(\"#\")]),a._v(\" 特点\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"Map 是一个无序的键值对集合，其中键必须是唯一的。\")]),a._v(\" \"),s(\"li\",[a._v(\"Map 允许通过键来快速检索值。\")]),a._v(\" \"),s(\"li\",[a._v(\"Map 是一个接口，因此可以存储各种类型的值。\")]),a._v(\" \"),s(\"li\",[a._v(\"Map 不是线程安全的。\")])]),a._v(\" \"),s(\"h2\",{attrs:{id:\"常用方法\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#常用方法\"}},[a._v(\"#\")]),a._v(\" 常用方法\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[s(\"code\",[a._v(\"put(key, value)\")]),a._v(\"：将键值对添加到 Map 中。\")]),a._v(\" \"),s(\"li\",[s(\"code\",[a._v(\"get(key)\")]),a._v(\"：通过键获取对应的值。\")]),a._v(\" \"),s(\"li\",[s(\"code\",[a._v(\"containsKey(key)\")]),a._v(\"：判断 Map 中是否包含指定的键。\")]),a._v(\" \"),s(\"li\",[s(\"code\",[a._v(\"remove(key)\")]),a._v(\"：通过键删除键值对。\")]),a._v(\" \"),s(\"li\",[s(\"code\",[a._v(\"size()\")]),a._v(\"：获取 Map 中键值对的数量。\")]),a._v(\" \"),s(\"li\",[s(\"code\",[a._v(\"isEmpty()\")]),a._v(\"：判断 Map 是否为空。\")]),a._v(\" \"),s(\"li\",[s(\"code\",[a._v(\"clear()\")]),a._v(\"：清空 Map。\")])]),a._v(\" \"),s(\"h2\",{attrs:{id:\"hashmap\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hashmap\"}},[a._v(\"#\")]),a._v(\" HashMap\")]),a._v(\" \"),s(\"p\",[a._v(\"HashMap 是 Map 接口的实现类，是一种常用且高效的 Map 实现。\")]),a._v(\" \"),s(\"p\",[a._v(\"HashMap 底层使用哈希表实现，通过哈希函数将键映射到数组索引位置，从而快速检索值。\")]),a._v(\" \"),s(\"p\",[a._v(\"HashMap 允许键和值为空，但键不能为空。\")]),a._v(\" \"),s(\"p\",[a._v(\"HashMap 不是线程安全的，如果需要线程安全的 Map，可以使用 ConcurrentHashMap。 ]\")]),a._v(\" \"),s(\"h2\",{attrs:{id:\"hashmap的实现原理\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hashmap的实现原理\"}},[a._v(\"#\")]),a._v(\" HashMap的实现原理\")]),a._v(\" \"),s(\"h3\",{attrs:{id:\"hashmap的数据结构-底层使用hash表数据结构-即数组和链表或红黑树\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hashmap的数据结构-底层使用hash表数据结构-即数组和链表或红黑树\"}},[a._v(\"#\")]),a._v(\" hashmap的数据结构：底层使用hash表数据结构，即数组和链表或红黑树\")]),a._v(\" \"),s(\"ol\",[s(\"li\",[a._v(\"当我们往hashmap中put元索时，利用key的hashcode重新hash计算出当前对象的元素在数组中的下标\")]),a._v(\" \"),s(\"li\",[a._v(\"存储时，如果出现hash值相同的key,此时有两种情况。\")])]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"a.如果key相同，则覆盖原始值；\")]),a._v(\" \"),s(\"li\",[a._v(\"b.如果key不同（出现冲突）,则将当前的key-value放入链表或红黑树中\")])]),a._v(\" \"),s(\"ol\",{attrs:{start:\"3\"}},[s(\"li\",[a._v(\"获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。\\n链表的长度大于8且数组长度大于64\\n转换为红黑树\")])]),a._v(\" \"),s(\"h2\",{attrs:{id:\"hashmap的扩容机制\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hashmap的扩容机制\"}},[a._v(\"#\")]),a._v(\" HashMap的扩容机制\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"在添加元素或初始化的时候需要调用resize方法进行扩容，第一次添加数据初始化数组长度为16,以后每次每次扩\\n容都是达到了扩容阈值（数组长度*0.75)\")]),a._v(\" \"),s(\"li\",[a._v(\"每次扩容的时候，都是扩容之前容量的2倍；\")]),a._v(\" \"),s(\"li\",[a._v(\"扩容之后，会新创建一个数组，需要把老数组中的数据挪动到新的数组中\\n没有hash冲突的节点，则直接使用e.hash&(newcap-1)计算新数组的索引位置\\n如果是红黑树，走红黑树的添加\\n如果是链表，则需更通历链表，可能需要拆分链表，判断（chash&oldcap是否为o,该元素的位置要么停留在原始位置，要么移\\n动到原始位置+增加的数组大小这个位置上\")])]),a._v(\" \"),s(\"h2\",{attrs:{id:\"linkedhashmap\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#linkedhashmap\"}},[a._v(\"#\")]),a._v(\" LinkedHashMap\")]),a._v(\" \"),s(\"p\",[a._v(\"LinkedHashMap 是 HashMap 的子类， LinkedHashMap 继承了 HashMap 的所有方法，并保留了插入顺序。\")]),a._v(\" \"),s(\"p\",[a._v(\"LinkedHashMap 保证了按照插入顺序遍历 Map 的顺序。\")]),a._v(\" \"),s(\"h2\",{attrs:{id:\"treemap\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#treemap\"}},[a._v(\"#\")]),a._v(\" TreeMap\")]),a._v(\" \"),s(\"p\",[a._v(\"TreeMap 是 Map 接口的实现类，TreeMap 继承了 AbstractMap，并实现了 NavigableMap 接口。\")]),a._v(\" \"),s(\"p\",[a._v(\"TreeMap 是一个有序的 Map，按照键的自然顺序或者自定义比较器排序。\")]),a._v(\" \"),s(\"p\",[a._v(\"TreeMap 允许键和值为空，但键不能为空。\")]),a._v(\" \"),s(\"p\",[a._v(\"TreeMap 不是线程安全的，如果需要线程安全的 Map，可以使用 ConcurrentSkipListMap。\")]),a._v(\" \"),s(\"h2\",{attrs:{id:\"concurrenthashmap\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#concurrenthashmap\"}},[a._v(\"#\")]),a._v(\" ConcurrentHashMap\")]),a._v(\" \"),s(\"p\",[a._v(\"ConcurrentHashMap 是 Map 接口的实现类，ConcurrentHashMap 继承了 AbstractMap，并实现了 ConcurrentMap 接口。\")]),a._v(\" \"),s(\"p\",[a._v(\"ConcurrentHashMap 是一个线程安全的 Map，通过分段锁实现并发访问。\")]),a._v(\" \"),s(\"p\",[a._v(\"ConcurrentHashMap 允许键和值为空，但键不能为空。\")]),a._v(\" \"),s(\"p\",[a._v(\"ConcurrentHashMap 不是按照插入顺序遍历 Map，而是按照插入顺序遍历分段锁的各个段。\")])])}),[],!1,null,null,null);s.default=e.exports}}]);","extractedComments":[]}