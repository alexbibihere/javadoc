(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{452:function(a,t,r){"use strict";r.r(t);var s=r(2),v=Object(s.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"jvm的组成主要分为三个部分-类加载器、运行时数据区、执行引擎。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm的组成主要分为三个部分-类加载器、运行时数据区、执行引擎。"}},[a._v("#")]),a._v(" JVM的组成主要分为三个部分： 类加载器、运行时数据区、执行引擎。")]),a._v(" "),t("h2",{attrs:{id:"类加载器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[a._v("#")]),a._v(" 类加载器")]),a._v(" "),t("p",[a._v("类加载器是 JVM 的重要组成部分，负责加载类文件并将类文件转换为运行时数据区的运行时数据结构。 JVM 自带的类加载器有：启动类加载器、扩展类加载器、系统类加载器。")]),a._v(" "),t("h3",{attrs:{id:"启动类加载器-bootstrap-class-loader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#启动类加载器-bootstrap-class-loader"}},[a._v("#")]),a._v(" 启动类加载器（Bootstrap Class Loader）")]),a._v(" "),t("p",[a._v("启动类加载器是 JVM 自带的类加载器，它负责加载 Java 运行环境中的核心类库，如 java.lang.String。启动类加载器的父类为 null，它使用 C++ 编写，是虚拟机自身的一部分。")]),a._v(" "),t("h3",{attrs:{id:"扩展类加载器-extension-class-loader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展类加载器-extension-class-loader"}},[a._v("#")]),a._v(" 扩展类加载器（Extension Class Loader）")]),a._v(" "),t("p",[a._v("扩展类加载器是 JVM 自带的类加载器，它负责加载 Java 运行环境的扩展类库，如 javax.swing.JButton。扩展类加载器的父类为启动类加载器。")]),a._v(" "),t("h3",{attrs:{id:"系统类加载器-system-class-loader"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#系统类加载器-system-class-loader"}},[a._v("#")]),a._v(" 系统类加载器（System Class Loader）")]),a._v(" "),t("p",[a._v("系统类加载器是 JVM 自带的类加载器，它负责加载用户类路径（classpath）上指定的类库，如 java.util.ArrayList。系统类加载器的父类为扩展类加载器。")]),a._v(" "),t("h2",{attrs:{id:"运行时数据区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区"}},[a._v("#")]),a._v(" 运行时数据区")]),a._v(" "),t("p",[a._v("运行时数据区包括方法区、堆、虚拟机栈、程序计数器。")]),a._v(" "),t("h3",{attrs:{id:"方法区-method-area"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区-method-area"}},[a._v("#")]),a._v(" 方法区（Method Area）")]),a._v(" "),t("p",[a._v("是各个线程共享的内存区域\n方法区是 JVM 运行时数据区的一种，用于存储类信息、常量、静态变量、即时编译器编译后的代码等。方法区的大小在 JVM 启动时确定，并且在虚拟机生命周期内不会发生垃圾回收。")]),a._v(" "),t("h3",{attrs:{id:"堆-heap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆-heap"}},[a._v("#")]),a._v(" 堆（Heap）")]),a._v(" "),t("p",[a._v("堆是 JVM 运行时数据区的另一种，用于存储对象实例和数组。堆的大小也是在 JVM 启动时确定，并且可以动态扩展。当堆中没有足够的内存空间进行分配时，JVM 会抛出 OutOfMemoryError 异常。")]),a._v(" "),t("h3",{attrs:{id:"虚拟机栈-vm-stack"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈-vm-stack"}},[a._v("#")]),a._v(" 虚拟机栈（VM Stack）")]),a._v(" "),t("p",[a._v("虚拟机栈是 JVM 运行时数据区的第三种，用于存储方法调用信息。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。")]),a._v(" "),t("h3",{attrs:{id:"程序计数器-program-counter-register"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#程序计数器-program-counter-register"}},[a._v("#")]),a._v(" 程序计数器（Program Counter Register）")]),a._v(" "),t("p",[a._v("程序计数器是 JVM 运行时数据区的第四种，是一个指针，指向当前线程执行的字节码指令。当线程切换时，PC 寄存器的值也会发生变化。")]),a._v(" "),t("h2",{attrs:{id:"执行引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行引擎"}},[a._v("#")]),a._v(" 执行引擎")]),a._v(" "),t("p",[a._v("执行引擎是 JVM 的核心，它负责解释字节码并执行程序。JVM 实现的执行引擎有：解释器、JIT 编译器、垃圾回收器。")]),a._v(" "),t("h3",{attrs:{id:"解释器-interpreter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解释器-interpreter"}},[a._v("#")]),a._v(" 解释器（Interpreter）")]),a._v(" "),t("p",[a._v("解释器是 JVM 的执行引擎，它逐条解释字节码，执行程序。解释器的执行速度较慢，但它占用内存少，适用于执行较小的程序。")]),a._v(" "),t("h3",{attrs:{id:"jit-编译器-just-in-time-compiler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jit-编译器-just-in-time-compiler"}},[a._v("#")]),a._v(" JIT 编译器（Just-In-Time Compiler）")]),a._v(" "),t("p",[a._v("JIT 编译器是 JVM 的执行引擎，它将热点代码编译成机器码，并缓存起来，以便下次执行时直接使用。JIT 编译器的执行速度较快，但它占用内存多，适用于执行较大的程序。")]),a._v(" "),t("h3",{attrs:{id:"垃圾回收器-garbage-collector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器-garbage-collector"}},[a._v("#")]),a._v(" 垃圾回收器（Garbage Collector）")]),a._v(" "),t("p",[a._v("垃圾回收器是 JVM 的执行引擎，它负责回收不再需要的内存，以便为新对象分配内存。JVM 实现的垃圾回收器有：串行垃圾回收器、并行垃圾回收器、并发垃圾回收器。")]),a._v(" "),t("h2",{attrs:{id:"堆栈的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#堆栈的区别"}},[a._v("#")]),a._v(" 堆栈的区别")]),a._v(" "),t("ul",[t("li",[a._v("栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储java对象\n数组的的。堆会gc垃圾回收，而栈不会。")]),a._v(" "),t("li",[a._v("栈内存是线程私有的，而堆内存是线程共有的。")]),a._v(" "),t("li",[a._v("两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。\n栈空间不足：java.lang.stackoverflowerror.\n堆空间不足：java.lang.outofmemoryerror.")])]),a._v(" "),t("h2",{attrs:{id:"类加载的过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类加载的过程"}},[a._v("#")]),a._v(" 类加载的过程")]),a._v(" "),t("ul",[t("li",[a._v("加载：查找和导入class文件")]),a._v(" "),t("li",[a._v("验证：保证加载类的准确性")]),a._v(" "),t("li",[a._v("准备：为类变量分配内存并设置类变量初始值")]),a._v(" "),t("li",[a._v("解析：把类中的符号引用转换为直接引用")]),a._v(" "),t("li",[a._v("初始化：对类的静态变量，静态代码块执行初始化操作")]),a._v(" "),t("li",[a._v("使用：jvm 开始从入口方法开始执行用户的程序代码")]),a._v(" "),t("li",[a._v("卸载：当用户程序代码执行完毕后，jvm便开始销毁创建的class对象。")])]),a._v(" "),t("h2",{attrs:{id:"定位垃圾的算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定位垃圾的算法"}},[a._v("#")]),a._v(" 定位垃圾的算法")]),a._v(" "),t("ul",[t("li",[a._v("引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，说明没有任何地方引用它，则可以回收。缺点是循环引用的问题。")]),a._v(" "),t("li",[a._v("可达性分析算法：通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为“引用链”，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。")])]),a._v(" "),t("h2",{attrs:{id:"垃圾回收的算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收的算法"}},[a._v("#")]),a._v(" 垃圾回收的算法")]),a._v(" "),t("ul",[t("li",[a._v("标记-清除算法：首先标记出所有需要回收的对象，然后统一回收掉所有被标记的对象。缺点是效率不高，标记和清除两个过程效率都不高。")]),a._v(" "),t("li",[a._v("复制算法：将内存分为大小相同的两块，每次只使用其中一块，当这一块的内存用完时，就将还存活的对象复制到另一块上面，然后清理掉第一块内存。缺点是内存浪费严重。")]),a._v(" "),t("li",[a._v("标记-整理算法：标记过程和标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。")])]),a._v(" "),t("h2",{attrs:{id:"jvm调优"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jvm调优"}},[a._v("#")]),a._v(" JVM调优")]),a._v(" "),t("ul",[t("li",[a._v("堆内存调优：-Xms：初始堆内存大小，默认为物理内存的1/64；-Xmx：最大堆内存大小，默认为物理内存的1/4；-Xmn：设置年轻代大小，默认为物理内存的1/2；-XX:NewRatio：设置年轻代和老年代的比例，默认为2；-XX:SurvivorRatio：设置新生代中Eden区与Survivor区的大小比例，默认为8；-XX:MaxTenuringThreshold：设置对象在新生代的最大年龄，默认为15；-XX:PretenureSizeThreshold：设置直接分配的最大内存，大于此值将直接在老年代分配。")]),a._v(" "),t("li",[a._v("垃圾回收器调优：-XX:+UseSerialGC：设置串行垃圾回收器；-XX:+UseParallelGC：设置并行垃圾回收器；-XX:+UseConcMarkSweepGC：设置并发标记-清除垃圾回收器；-XX:+UseG1GC：设置G1垃圾回收器。")]),a._v(" "),t("li",[a._v("其他调优：-XX:PermSize：设置永久代初始大小；-XX:MaxPermSize：设置永久代最大大小；-XX:PrintGCDetails：打印详细的GC信息；-XX:PrintGCTimeStamps：打印GC的时间戳；-XX:PrintGCDateStamps：打印GC的日期时间戳；-Xloggc：指定GC日志路径；-XX:+HeapDumpOnOutOfMemoryError：当OOM发生时，自动生成堆转储快照文件。")])]),a._v(" "),t("h2",{attrs:{id:"java内存泄露的排查思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java内存泄露的排查思路"}},[a._v("#")]),a._v(" Java内存泄露的排查思路")]),a._v(" "),t("p",[a._v("内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况")]),a._v(" "),t("ol",[t("li",[a._v("通过jmap或设置jvm参数获取堆内存快照dump")]),a._v(" "),t("li",[a._v("通过工具，visualvm去分析dump文件，visualvm可以加载离线的dump文件")]),a._v(" "),t("li",[a._v("通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题")]),a._v(" "),t("li",[a._v("找到对应的代码，通过阅读上下文的情况，进行修复即可")])]),a._v(" "),t("h2",{attrs:{id:"cpu飙高排查思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cpu飙高排查思路"}},[a._v("#")]),a._v(" CPU飙高排查思路")]),a._v(" "),t("ol",[t("li",[a._v("使用top命令查看占用cpu的情况")]),a._v(" "),t("li",[a._v("通过top命令查看后，可以查看是哪一个进程占用cpb较高")]),a._v(" "),t("li",[a._v("使用ps命令查看进程中的线程信息")]),a._v(" "),t("li",[a._v("使用jstack命令查看进程中哪些线程出现了问题，最终定位问题")])])])}),[],!1,null,null,null);t.default=v.exports}}]);