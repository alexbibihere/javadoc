(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{475:function(v,_,a){"use strict";a.r(_);var i=a(2),t=Object(i.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"springcloud常用组件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#springcloud常用组件"}},[v._v("#")]),v._v(" SpringCloud常用组件")]),v._v(" "),_("ul",[_("li",[v._v("Eureka：服务注册与发现")]),v._v(" "),_("li",[v._v("Nacos：更易于构建云原生应用的服务注册中心和配置中心")]),v._v(" "),_("li",[v._v("Ribbon：客户端负载均衡")]),v._v(" "),_("li",[v._v("Feign：声明式HTTP客户端")]),v._v(" "),_("li",[v._v("Hystrix：容错管理工具")]),v._v(" "),_("li",[v._v("Zuul：API网关")]),v._v(" "),_("li",[v._v("Config：配置管理中心")]),v._v(" "),_("li",[v._v("Sleuth：分布式链路跟踪")]),v._v(" "),_("li",[v._v("Zipkin：分布式链路跟踪系统")]),v._v(" "),_("li",[v._v("Spring Cloud Stream：微服务间消息驱动")]),v._v(" "),_("li",[v._v("Spring Cloud Bus：事件驱动配置更新")]),v._v(" "),_("li",[v._v("Spring Cloud Gateway：API网关")]),v._v(" "),_("li",[v._v("Spring Cloud Security：安全认证与授权")]),v._v(" "),_("li",[v._v("Spring Cloud Data Flow：微服务编排")])]),v._v(" "),_("h2",{attrs:{id:"nacos和eureka的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nacos和eureka的区别"}},[v._v("#")]),v._v(" Nacos和Eureka的区别")]),v._v(" "),_("h3",{attrs:{id:"共同点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#共同点"}},[v._v("#")]),v._v(" 共同点")]),v._v(" "),_("ul",[_("li",[v._v("都支持服务注册和服务拉取")]),v._v(" "),_("li",[v._v("都支持服务提供者心跳方式做健康检测")])]),v._v(" "),_("h3",{attrs:{id:"nacos与eureka的区别-注册中心"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#nacos与eureka的区别-注册中心"}},[v._v("#")]),v._v(" nacos与eureka的区别（注册中心）")]),v._v(" "),_("ul",[_("li",[v._v("nacos支持服务端主动检测提供者状态：临时实例采用心既模式，非临时实例采用主动检测模式")]),v._v(" "),_("li",[v._v("临时实例心跳不正常会被剔除，非临时实例则不会被剔除")]),v._v(" "),_("li",[v._v("nacos支持服务列表变更的消息推送模式，服务列表更新更及时")]),v._v(" "),_("li",[v._v("nacos集群默认采用ap方式，当集群中存在非临时实例时，采用cp模式；eureka采用ap方式\nnacos还支持了配置中心，eureka则只有注册中心，也是选择使用nacos的一个重要原因")])]),v._v(" "),_("h2",{attrs:{id:"ribbon"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ribbon"}},[v._v("#")]),v._v(" Ribbon")]),v._v(" "),_("p",[v._v("Ribbon是一个基于HTTP和TCP客户端的负载均衡器。它可以让客户端代码透明地调用服务，在云端的多个服务实例之间自动分配请求")]),v._v(" "),_("h3",{attrs:{id:"ribbon的负载均衡策略有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#ribbon的负载均衡策略有哪些"}},[v._v("#")]),v._v(" Ribbon的负载均衡策略有哪些")]),v._v(" "),_("ul",[_("li",[v._v("roundrobinrule:简单轮询服务列表来选择服务器")]),v._v(" "),_("li",[v._v("weightedresponsetimerule:按照权重来选择服务器，响应时间越长，权重越小")]),v._v(" "),_("li",[v._v("randomrule:随机选择一个可用的服务器")]),v._v(" "),_("li",[v._v("zoneavoidancerule:区域敏感策略，以区域可用的服务器为基础进行服务器的选择。使用zone对服务\n器进行分类，这个zone可以理解为一个机房，一个机架等。而后再对zone内的多个服务做轮询（默认）")])]),v._v(" "),_("h2",{attrs:{id:"hystrix"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hystrix"}},[v._v("#")]),v._v(" Hystrix")]),v._v(" "),_("p",[v._v("Hystrix是一个容错管理工具，用来隔离出故障影响的服务，从而避免级联故障，提高系统的弹性。Hystrix能够监控服务的调用，在调用失败时，通过熔断机制，快速失败，避免长时间的等待，避免服务雪崩。")]),v._v(" "),_("h3",{attrs:{id:"什么是服务雪崩-怎么解决这个问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是服务雪崩-怎么解决这个问题"}},[v._v("#")]),v._v(" 什么是服务雪崩，怎么解决这个问题？")]),v._v(" "),_("ul",[_("li",[v._v("服务雪崩：一个服务失败，导致整条链路的服务都失败的情形")]),v._v(" "),_("li",[v._v("服务降级：服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得\n不可用，确保服务不会崩溃，一般在实际开发中与feign接口整合，编写降级逻辑")]),v._v(" "),_("li",[v._v("服务烟断：默认关闭。需要手动打开，如果检测到10秒内请求的失败率超过50%,就较发熔断机制。之后每隔\n5秒重新尝试请求微服务，如果微服务不能响应，继续走烟断机制。如果微服务可达，则关闭熔断机制，恢复\n正常请求")])]),v._v(" "),_("h2",{attrs:{id:"限流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#限流"}},[v._v("#")]),v._v(" 限流")]),v._v(" "),_("ul",[_("li",[v._v("Tomcat：基于请求数的限流  设置最大连接数")]),v._v(" "),_("li",[v._v("Nginx：漏桶算法")]),v._v(" "),_("li",[v._v("网关：令牌桶算法")]),v._v(" "),_("li",[v._v("自定义拦截器")])]),v._v(" "),_("h1",{attrs:{id:"分布式事务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务"}},[v._v("#")]),v._v(" 分布式事务")]),v._v(" "),_("ul",[_("li",[v._v("2PC：两阶段提交协议，是一种XA协议，是一种分布式事务协议，是一种通过两阶段提交来完成分布式事务的协议。")]),v._v(" "),_("li",[v._v("3PC：三阶段提交协议，是一种XA协议，是一种分布式事务协议，是一种通过三阶段提交来完成分布式事务的协议。")]),v._v(" "),_("li",[v._v("TCC：是一种补偿型的分布式事务协议，是一种通过try-confirm-cancel来完成分布式事务的协议。")]),v._v(" "),_("li",[v._v("本地消息表：是一种基于数据库的分布式事务解决方案，是一种通过在本地数据库中插入消息的方式来完成分布式事务的方案。")]),v._v(" "),_("li",[v._v("基于MQ的最终一致性方案：是一种基于消息队列的分布式事务解决方案，是一种通过消息队列来实现最终一致性的方案。")]),v._v(" "),_("li",[v._v("最大努力通知（异步确保）：是一种基于消息队列的分布式事务解决方案，是一种通过消息队列来实现最终一致性的方案。")]),v._v(" "),_("li",[v._v("Saga：是一种长事务的分布式事务解决方案，是一种通过业务活动来驱动分布式事务的方案。")]),v._v(" "),_("li",[v._v("事务补偿：是一种补偿型的分布式事务解决方案，是一种通过业务活动来驱动分布式事务的方案。")]),v._v(" "),_("li",[v._v("最大努力通知（异步确保）：是一种基于消息队列的分布式事务解决方案，是一种通过消息队列来实现最终一致性的方案。")]),v._v(" "),_("li",[v._v("基于事件的最终一致性方案：是一种基于事件的分布式事务解决方案，是一种通过事件驱动的方式来实现最终一致性的方案。")]),v._v(" "),_("li",[v._v("基于可靠消息的最终一致性方案：是一种基于可靠消息的分布式事务解决方案，是一种通过可靠消息来实现最终一致性的方案。")]),v._v(" "),_("li",[v._v("基于多版本并发控制（MVCC）的最终一致性方案：是一种基于多版本并发控制的分布式事务解决方案，是一种通过多版本并发控制来实现最终一致性的方案。")])]),v._v(" "),_("h2",{attrs:{id:"简历上写的微服务-只要是发生了多个服务之间的写操作-都需要进行分布式事务控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简历上写的微服务-只要是发生了多个服务之间的写操作-都需要进行分布式事务控制"}},[v._v("#")]),v._v(" 简历上写的微服务，只要是发生了多个服务之间的写操作，都需要进行分布式事务控制")]),v._v(" "),_("p",[v._v("描述项目中采用的哪种方案（seata| mq)")]),v._v(" "),_("ol",[_("li",[v._v("seata的xa模式，cp,需要互相等待各个分支事务提交，可以保证强一致性，性能差 (银行业务)")]),v._v(" "),_("li",[v._v("seata的at模式。 ap,底层使用undo log 实现，性能好 (互联网业务)")]),v._v(" "),_("li",[v._v("seata的tcc模式，ap,性能较好，不过需要人工编码实现 (银行业务)")]),v._v(" "),_("li",[v._v("mq模式实现分布式事务，在a服务与数据的时候，需要在同一个事务内发送消息到另外一个事务\n,异步，性能最好 (互联网业务)")])]),v._v(" "),_("h2",{attrs:{id:"分布式服务的接口幂等性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式服务的接口幂等性"}},[v._v("#")]),v._v(" 分布式服务的接口幂等性")]),v._v(" "),_("p",[v._v("幂等： 多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致\n场景：")]),v._v(" "),_("p",[v._v("● 用户重复点击\n● MQ消息重复\n● 应用使用失败或超时重试机制")]),v._v(" "),_("h3",{attrs:{id:"解决方案"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[v._v("#")]),v._v(" 解决方案：")]),v._v(" "),_("ul",[_("li",[v._v("唯一索引 – 防止新增脏数据")]),v._v(" "),_("li",[v._v("token机制 – 防止页面重复提交")]),v._v(" "),_("li",[v._v("悲观锁 – 获取数据的时候加锁(锁表或锁行)")]),v._v(" "),_("li",[v._v("乐观锁 – 基于版本号version实现, 在更新数据那一刻校验数据")]),v._v(" "),_("li",[v._v("分布式锁 – redis(jedis、redisson)或zookeeper实现")]),v._v(" "),_("li",[v._v("状态机 – 状态变更, 更新数据时判断状态")])]),v._v(" "),_("h3",{attrs:{id:"token-redis"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#token-redis"}},[v._v("#")]),v._v(" token+redis")]),v._v(" "),_("p",[v._v("为需要保证幂等性的每一次请求创建一个唯一标识 token, 先获取 token, 并将此 token存入redis, 请求接口时, 将此 token放到header或者作为请求参数请求接口, 后端接口判断redis中是否存在此 token:")]),v._v(" "),_("ul",[_("li",[v._v("如果存在, 正常处理业务逻辑, 并从redis中删除此 token, 那么, 如果是重复请求, 由于 token已被删除, 则不能通过校验, 返回 请勿重复操作提示")]),v._v(" "),_("li",[v._v("如果不存在, 说明参数不合法或者是重复请求, 返回提示即可")])])])}),[],!1,null,null,null);_.default=t.exports}}]);