(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{478:function(a,e,v){"use strict";v.r(e);var p=v(2),t=Object(p.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[a._v("#")]),a._v(" 介绍")]),a._v(" "),e("p",[a._v("Map 是一种无序的键值对集合，其中键必须是唯一的。Map 允许通过键来快速检索值。")]),a._v(" "),e("h2",{attrs:{id:"特点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[a._v("#")]),a._v(" 特点")]),a._v(" "),e("ul",[e("li",[a._v("Map 是一个无序的键值对集合，其中键必须是唯一的。")]),a._v(" "),e("li",[a._v("Map 允许通过键来快速检索值。")]),a._v(" "),e("li",[a._v("Map 是一个接口，因此可以存储各种类型的值。")]),a._v(" "),e("li",[a._v("Map 不是线程安全的。")])]),a._v(" "),e("h2",{attrs:{id:"常用方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用方法"}},[a._v("#")]),a._v(" 常用方法")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("put(key, value)")]),a._v("：将键值对添加到 Map 中。")]),a._v(" "),e("li",[e("code",[a._v("get(key)")]),a._v("：通过键获取对应的值。")]),a._v(" "),e("li",[e("code",[a._v("containsKey(key)")]),a._v("：判断 Map 中是否包含指定的键。")]),a._v(" "),e("li",[e("code",[a._v("remove(key)")]),a._v("：通过键删除键值对。")]),a._v(" "),e("li",[e("code",[a._v("size()")]),a._v("：获取 Map 中键值对的数量。")]),a._v(" "),e("li",[e("code",[a._v("isEmpty()")]),a._v("：判断 Map 是否为空。")]),a._v(" "),e("li",[e("code",[a._v("clear()")]),a._v("：清空 Map。")])]),a._v(" "),e("h2",{attrs:{id:"hashmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hashmap"}},[a._v("#")]),a._v(" HashMap")]),a._v(" "),e("p",[a._v("HashMap 是 Map 接口的实现类，是一种常用且高效的 Map 实现。")]),a._v(" "),e("p",[a._v("HashMap 底层使用哈希表实现，通过哈希函数将键映射到数组索引位置，从而快速检索值。")]),a._v(" "),e("p",[a._v("HashMap 允许键和值为空，但键不能为空。")]),a._v(" "),e("p",[a._v("HashMap 不是线程安全的，如果需要线程安全的 Map，可以使用 ConcurrentHashMap。")]),a._v(" "),e("h2",{attrs:{id:"linkedhashmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linkedhashmap"}},[a._v("#")]),a._v(" LinkedHashMap")]),a._v(" "),e("p",[a._v("LinkedHashMap 是 HashMap 的子类， LinkedHashMap 继承了 HashMap 的所有方法，并保留了插入顺序。")]),a._v(" "),e("p",[a._v("LinkedHashMap 保证了按照插入顺序遍历 Map 的顺序。")]),a._v(" "),e("h2",{attrs:{id:"treemap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#treemap"}},[a._v("#")]),a._v(" TreeMap")]),a._v(" "),e("p",[a._v("TreeMap 是 Map 接口的实现类，TreeMap 继承了 AbstractMap，并实现了 NavigableMap 接口。")]),a._v(" "),e("p",[a._v("TreeMap 是一个有序的 Map，按照键的自然顺序或者自定义比较器排序。")]),a._v(" "),e("p",[a._v("TreeMap 允许键和值为空，但键不能为空。")]),a._v(" "),e("p",[a._v("TreeMap 不是线程安全的，如果需要线程安全的 Map，可以使用 ConcurrentSkipListMap。")]),a._v(" "),e("h2",{attrs:{id:"concurrenthashmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[a._v("#")]),a._v(" ConcurrentHashMap")]),a._v(" "),e("p",[a._v("ConcurrentHashMap 是 Map 接口的实现类，ConcurrentHashMap 继承了 AbstractMap，并实现了 ConcurrentMap 接口。")]),a._v(" "),e("p",[a._v("ConcurrentHashMap 是一个线程安全的 Map，通过分段锁实现并发访问。")]),a._v(" "),e("p",[a._v("ConcurrentHashMap 允许键和值为空，但键不能为空。")]),a._v(" "),e("p",[a._v("ConcurrentHashMap 不是按照插入顺序遍历 Map，而是按照插入顺序遍历分段锁的各个段。")])])}),[],!1,null,null,null);e.default=t.exports}}]);