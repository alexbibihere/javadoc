(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{463:function(a,t,v){"use strict";v.r(t);var r=v(2),_=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"并发线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#并发线程"}},[a._v("#")]),a._v(" 并发线程")]),a._v(" "),t("h2",{attrs:{id:"线程的概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的概念"}},[a._v("#")]),a._v(" 线程的概念")]),a._v(" "),t("p",[a._v("线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一个进程可以包含多个线程，每条线程并行执行不同的任务。")]),a._v(" "),t("h2",{attrs:{id:"线程的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的特点"}},[a._v("#")]),a._v(" 线程的特点")]),a._v(" "),t("ul",[t("li",[a._v("线程是轻量级的，占用内存很小，但不如进程轻量级。")]),a._v(" "),t("li",[a._v("线程可以并发执行，一个进程中的多个线程可以同时运行。")]),a._v(" "),t("li",[a._v("线程间可以共享进程中的数据。")]),a._v(" "),t("li",[a._v("线程可以随时创建和撤销。")])]),a._v(" "),t("h2",{attrs:{id:"线程的状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的状态"}},[a._v("#")]),a._v(" 线程的状态")]),a._v(" "),t("p",[a._v("线程在生命周期中会经历不同的状态，这些状态可以分为：")]),a._v(" "),t("ul",[t("li",[a._v("新建状态：线程刚被创建，尚未启动。")]),a._v(" "),t("li",[a._v("就绪状态：线程已准备好运行，等待被调度运行。")]),a._v(" "),t("li",[a._v("运行状态：线程正在执行任务。")]),a._v(" "),t("li",[a._v("阻塞状态：线程暂停执行，等待其他线程执行。")]),a._v(" "),t("li",[a._v("结束状态：线程执行完毕。")])]),a._v(" "),t("h2",{attrs:{id:"线程的创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的创建"}},[a._v("#")]),a._v(" 线程的创建")]),a._v(" "),t("p",[a._v("在Java中，创建线程有两种方式：")]),a._v(" "),t("ul",[t("li",[a._v("通过继承Thread类创建线程，并重写run()方法，在run()方法中实现线程要执行的任务。")]),a._v(" "),t("li",[a._v("通过实现Runnable接口创建线程，并重写run()方法，在run()方法中实现线程要执行的任务。")]),a._v(" "),t("li",[a._v("通过ExecutorService创建线程池，调用ExecutorService的submit()方法提交任务，ExecutorService会自动创建线程执行任务。")])]),a._v(" "),t("h2",{attrs:{id:"线程的同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的同步"}},[a._v("#")]),a._v(" 线程的同步")]),a._v(" "),t("p",[a._v("在多线程环境下，线程之间共享数据时，需要同步机制来保证数据的一致性。"),t("br"),a._v("\nJava中提供了多种同步机制，如：")]),a._v(" "),t("ul",[t("li",[a._v("同步代码块：通过synchronized关键字来实现同步，synchronized关键字可以作用于方法、代码块或类，当一个线程访问某个synchronized代码块时，其他线程必须等待，直到该线程执行完毕，才能执行该代码块后面的语句。")]),a._v(" "),t("li",[a._v("同步方法：通过在方法声明上使用synchronized关键字来实现同步，当一个线程调用该方法时，其他线程必须等待，直到该线程执行完毕，才能执行该方法后面的语句。")]),a._v(" "),t("li",[a._v("同步静态方法：通过在静态方法声明上使用synchronized关键字来实现同步，当一个线程调用该静态方法时，其他线程必须等待，直到该线程执行完毕，才能执行该静态方法后面的语句。")]),a._v(" "),t("li",[a._v("同步类：通过在类声明上使用synchronized关键字来实现同步，当一个线程访问该类的所有实例方法时，其他线程必须等待，直到该线程执行完毕，才能执行该类的所有实例方法后面的语句。")]),a._v(" "),t("li",[a._v("锁：通过Lock接口或ReentrantLock类来实现同步，Lock接口提供了比synchronized更细粒度的同步控制，允许多个线程同时访问某个资源，而ReentrantLock类是Lock接口的实现类。")])]),a._v(" "),t("h2",{attrs:{id:"线程的死锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的死锁"}},[a._v("#")]),a._v(" 线程的死锁")]),a._v(" "),t("p",[a._v("死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。"),t("br"),a._v("\n死锁的四个必要条件：")]),a._v(" "),t("ul",[t("li",[a._v("互斥条件：一个资源每次只能被一个线程使用。")]),a._v(" "),t("li",[a._v("请求和保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。")]),a._v(" "),t("li",[a._v("不可抢占条件：线程已经获得的资源在未使用完毕之前，不能被抢占。")]),a._v(" "),t("li",[a._v("环路等待条件：若有两个线程互相等待，则必然存在环路。")])]),a._v(" "),t("h2",{attrs:{id:"线程的优先级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的优先级"}},[a._v("#")]),a._v(" 线程的优先级")]),a._v(" "),t("p",[a._v("Java中提供了Thread.setPriority()方法来设置线程的优先级，优先级的取值范围是1~10，数值越大优先级越高。"),t("br"),a._v("\n线程优先级的作用：")]),a._v(" "),t("ul",[t("li",[a._v("线程优先级高的线程会优先执行。")]),a._v(" "),t("li",[a._v("线程优先级相同的线程，谁先抢占CPU，谁就先执行。")]),a._v(" "),t("li",[a._v("线程优先级低的线程，如果一直得不到执行，就会被暂停。")])]),a._v(" "),t("h2",{attrs:{id:"线程的安全"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的安全"}},[a._v("#")]),a._v(" 线程的安全")]),a._v(" "),t("h3",{attrs:{id:"synchronized关键字的底层原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized关键字的底层原理"}},[a._v("#")]),a._v(" Synchronized关键字的底层原理")]),a._v(" "),t("ul",[t("li",[a._v("synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】")]),a._v(" "),t("li",[a._v("它的底层由monitor实现的，monitor是jvm级别的对象（c++实现）,\n线程获得锁需要使用对象（锁）关联monitor")]),a._v(" "),t("li",[a._v("在monitor内部有三个属性，分别是owner,entrylist,waitset")]),a._v(" "),t("li",[a._v("其中owner是关 是关联的获得锁的线程，并且只能关联一个线程；entrylist\n关联的是处于阻塞状态的线程；waitset关联的是处于waiting状态的线")])]),a._v(" "),t("h3",{attrs:{id:"synchronized-的锁"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-的锁"}},[a._v("#")]),a._v(" synchronized 的锁")]),a._v(" "),t("ul",[t("li",[a._v("偏向锁   （锁只能被一个线程持有，其他线程只能等待）")]),a._v(" "),t("li",[a._v("轻量级锁  （不同的线程可以同时持有，但只有一个线程能执行）")]),a._v(" "),t("li",[a._v("重量级锁  （多线程竞争，性能差）\n一旦锁发生了竞争，都会升级为重量级锁")])]),a._v(" "),t("h3",{attrs:{id:"cas-compare-and-swap-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cas-compare-and-swap-算法"}},[a._v("#")]),a._v(" CAS（Compare And Swap）算法")]),a._v(" "),t("ul",[t("li",[a._v("CAS是一种无锁算法，是一种原子操作，它是一条CPU指令，用于在多线程环境下，保证共享变量的原子性，即对共享变量进行比较并替换。")]),a._v(" "),t("li",[a._v("CAS是基于乐观锁的一种实现方式，它总是假设最坏的情况，认为共享变量可能被其他线程修改，因此在更新共享变量时，采用CAS算法，只有在共享变量的当前值和期望值相等时，才会更新共享变量的值。")])]),a._v(" "),t("h3",{attrs:{id:"volatile关键字的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#volatile关键字的作用"}},[a._v("#")]),a._v(" volatile关键字的作用")]),a._v(" "),t("ul",[t("li",[a._v("volatile关键字的作用是使变量在多个线程间可见，即一个线程修改了volatile变量的值，其他线程能够立即得知这个修改。")]),a._v(" "),t("li",[a._v("防止指令重排序，volatile关键字能禁止编译器对指令进行重排序，从而保证volatile变量的可见性。")])]),a._v(" "),t("h3",{attrs:{id:"aqs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aqs"}},[a._v("#")]),a._v(" AQS")]),a._v(" "),t("h4",{attrs:{id:"reentrantlock"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reentrantlock"}},[a._v("#")]),a._v(" ReentrantLock")]),a._v(" "),t("ul",[t("li",[a._v("ReentrantLock是一种可重入锁，它能够确保一个线程在获取锁的同时能够再次获取该锁，而不会出现死锁。")]),a._v(" "),t("li",[a._v("ReentrantLock的锁分为公平锁和非公平锁，公平锁是指按照申请锁的顺序来获取锁，非公平锁则不保证锁的获取顺序。")]),a._v(" "),t("li",[a._v("ReentrantLock的锁降级是指将持有锁的线程从偏向锁升级为轻量级锁或重量级锁。")]),a._v(" "),t("li",[a._v("ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lockInterruptibly()方法可中断正在等待锁的线程。")]),a._v(" "),t("li",[a._v("利用CAS和AQS可以实现高效且正确的锁机制。")])]),a._v(" "),t("h4",{attrs:{id:"countdownlatch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#countdownlatch"}},[a._v("#")]),a._v(" CountDownLatch")]),a._v(" "),t("ul",[t("li",[a._v("CountDownLatch是一个同步工具类，它允许一个或多个线程等待，直到其他线程的操作执行完毕后再执行。")]),a._v(" "),t("li",[a._v("CountDownLatch的作用是让一组线程等待直到最后一个线程完成某项操作后，再开始执行。")]),a._v(" "),t("li",[a._v("CountDownLatch的计数器只能使用一次，一旦计数器值为0，则不能重置。")])]),a._v(" "),t("h4",{attrs:{id:"cyclicbarrier"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cyclicbarrier"}},[a._v("#")]),a._v(" CyclicBarrier")]),a._v(" "),t("ul",[t("li",[a._v("CyclicBarrier是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点（也可以叫同步点）时再同时执行。")]),a._v(" "),t("li",[a._v("CyclicBarrier的作用是让一组线程等待至某个状态，然后一起执行。")]),a._v(" "),t("li",[a._v("CyclicBarrier的计数器可以重置，所以它可以被重用。")])]),a._v(" "),t("h4",{attrs:{id:"semaphore"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#semaphore"}},[a._v("#")]),a._v(" Semaphore")]),a._v(" "),t("ul",[t("li",[a._v("Semaphore是一个计数信号量，它用来控制对共享资源的访问数量。")]),a._v(" "),t("li",[a._v("Semaphore的作用是控制同时访问共享资源的线程数量，Semaphore最多允许一个线程持有该Semaphore，其他线程则需要等待。")]),a._v(" "),t("li",[a._v("Semaphore提供了一种限制并发线程数量的机制。")])]),a._v(" "),t("h3",{attrs:{id:"concurrenthashmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concurrenthashmap"}},[a._v("#")]),a._v(" ConcurrentHashMap")]),a._v(" "),t("p",[a._v("concurrenthashmap是一种线程安全的高效map集合\n底层数据结构：\njdk1.7底层采用分段的数组+链表实现\njdk1.8采用的数据结构跟hashmap1.8的结构一样，数组+链表/红黑二叉树。\n采用CAS+synchronized保证并发安全。")]),a._v(" "),t("ul",[t("li",[a._v("CAS控制数组节点的添加")]),a._v(" "),t("li",[a._v("synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题，效率得到提升")])]),a._v(" "),t("h2",{attrs:{id:"线程池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池"}},[a._v("#")]),a._v(" 线程池")]),a._v(" "),t("p",[a._v("线程池是一种用来管理线程的工具，它可以提高程序的响应速度，减少资源消耗，并且可以对线程进行管理和监控。")]),a._v(" "),t("h3",{attrs:{id:"线程池的核心参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池的核心参数"}},[a._v("#")]),a._v(" 线程池的核心参数")]),a._v(" "),t("ul",[t("li",[a._v("corepoolsize核心线程数目")]),a._v(" "),t("li",[a._v("maximumpoolsize最大线程数目（核心线程+救急线程的最大数目）")]),a._v(" "),t("li",[a._v("keepalivetime 生存时间-救急线程的生存时间，生存时间内没有新任务，此线程资源会释放")]),a._v(" "),t("li",[a._v("unit 时间单位-救急线程的生存时间单位，如秒，毫秒等")]),a._v(" "),t("li",[a._v("workqueue,当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务")]),a._v(" "),t("li",[a._v("threadfactory 线程工厂，可以定制线程对象的创建，例如设置线程名字，是否是守护线程等")]),a._v(" "),t("li",[a._v("handler拒绝策略当所有线程都在繁忙，workqueueue 也放满时，会触发拒绝策略。")])]),a._v(" "),t("h3",{attrs:{id:"你们项目哪里用到了多线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#你们项目哪里用到了多线程"}},[a._v("#")]),a._v(" 你们项目哪里用到了多线程")]),a._v(" "),t("ul",[t("li",[a._v("批量导入：使用了线程池+countdownlatch批量把数据库中的数据导入到了\nes(任意）中，避免oom")]),a._v(" "),t("li",[a._v("数据汇总：调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依\n赖关系，就可以使用线程池+future来提升性能")]),a._v(" "),t("li",[a._v("异步线程（线程池）:为了避免下一级方法影响上一级方法（性能考虑）,可\n使用异步线程调用下一个方法（不需要下一级方法返回值）,可以提升方法响\n应时间")])]),a._v(" "),t("h3",{attrs:{id:"谈谈你对threadlocal的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#谈谈你对threadlocal的理解"}},[a._v("#")]),a._v(" 谈谈你对threadlocal的理解")]),a._v(" "),t("ul",[t("li",[a._v("1.threadlocal可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】\n,避免争用引发的线程安全问题")]),a._v(" "),t("li",[a._v("2.threadlocal同时实现了线程内的资源共享")]),a._v(" "),t("li",[a._v("3.每个线程内有一个threadlocalmap类型的成员变量，用来存储资源对象\na)调用set方法，就是以threadlocal自己作为key,资源对象作为value,放入当前线\n程的 threadlocalmap 集合中\nb)调用get方法，就是以threadlocal自己作为key,到当前线程中查找关联的资源值\nc)调用remove方法，就是以threadlocal 自己作为key,移除当前线程关联的资源值")]),a._v(" "),t("li",[a._v("4.threadlocal内存泄漏问题\nthreadlocaimap 中的k@ 是弱引用，值为强引用；key会被gc释放内存，关联value\n的内存并不会释放，建议主动remove释放key,value")])])])}),[],!1,null,null,null);t.default=_.exports}}]);