---
icon: pen-to-square
date: 2025-04-03
title: 线程
---
# 并发线程
## 线程的概念
线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位。一个进程可以包含多个线程，每条线程并行执行不同的任务。

## 线程的特点
- 线程是轻量级的，占用内存很小，但不如进程轻量级。
- 线程可以并发执行，一个进程中的多个线程可以同时运行。
- 线程间可以共享进程中的数据。
- 线程可以随时创建和撤销。

## 线程的状态
线程在生命周期中会经历不同的状态，这些状态可以分为：
- 新建状态：线程刚被创建，尚未启动。
- 就绪状态：线程已准备好运行，等待被调度运行。
- 运行状态：线程正在执行任务。
- 阻塞状态：线程暂停执行，等待其他线程执行。
- 结束状态：线程执行完毕。

## 线程的创建
在Java中，创建线程有两种方式：
- 通过继承Thread类创建线程，并重写run()方法，在run()方法中实现线程要执行的任务。
- 通过实现Runnable接口创建线程，并重写run()方法，在run()方法中实现线程要执行的任务。
- 通过ExecutorService创建线程池，调用ExecutorService的submit()方法提交任务，ExecutorService会自动创建线程执行任务。

## 线程的同步
在多线程环境下，线程之间共享数据时，需要同步机制来保证数据的一致性。  
Java中提供了多种同步机制，如：
- 同步代码块：通过synchronized关键字来实现同步，synchronized关键字可以作用于方法、代码块或类，当一个线程访问某个synchronized代码块时，其他线程必须等待，直到该线程执行完毕，才能执行该代码块后面的语句。
- 同步方法：通过在方法声明上使用synchronized关键字来实现同步，当一个线程调用该方法时，其他线程必须等待，直到该线程执行完毕，才能执行该方法后面的语句。
- 同步静态方法：通过在静态方法声明上使用synchronized关键字来实现同步，当一个线程调用该静态方法时，其他线程必须等待，直到该线程执行完毕，才能执行该静态方法后面的语句。
- 同步类：通过在类声明上使用synchronized关键字来实现同步，当一个线程访问该类的所有实例方法时，其他线程必须等待，直到该线程执行完毕，才能执行该类的所有实例方法后面的语句。
- 锁：通过Lock接口或ReentrantLock类来实现同步，Lock接口提供了比synchronized更细粒度的同步控制，允许多个线程同时访问某个资源，而ReentrantLock类是Lock接口的实现类。

## 线程的死锁
死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。  
死锁的四个必要条件：
- 互斥条件：一个资源每次只能被一个线程使用。
- 请求和保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
- 不可抢占条件：线程已经获得的资源在未使用完毕之前，不能被抢占。
- 环路等待条件：若有两个线程互相等待，则必然存在环路。

## 线程的优先级
Java中提供了Thread.setPriority()方法来设置线程的优先级，优先级的取值范围是1~10，数值越大优先级越高。  
线程优先级的作用：
- 线程优先级高的线程会优先执行。
- 线程优先级相同的线程，谁先抢占CPU，谁就先执行。
- 线程优先级低的线程，如果一直得不到执行，就会被暂停。

## 线程的安全

### Synchronized关键字的底层原理
- synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】
- 它的底层由monitor实现的，monitor是jvm级别的对象（c++实现）,
线程获得锁需要使用对象（锁）关联monitor
- 在monitor内部有三个属性，分别是owner,entrylist,waitset
- 其中owner是关 是关联的获得锁的线程，并且只能关联一个线程；entrylist
关联的是处于阻塞状态的线程；waitset关联的是处于waiting状态的线

### synchronized 的锁
- 偏向锁   （锁只能被一个线程持有，其他线程只能等待）
- 轻量级锁  （不同的线程可以同时持有，但只有一个线程能执行）
- 重量级锁  （多线程竞争，性能差）
 一旦锁发生了竞争，都会升级为重量级锁

### CAS（Compare And Swap）算法
- CAS是一种无锁算法，是一种原子操作，它是一条CPU指令，用于在多线程环境下，保证共享变量的原子性，即对共享变量进行比较并替换。
- CAS是基于乐观锁的一种实现方式，它总是假设最坏的情况，认为共享变量可能被其他线程修改，因此在更新共享变量时，采用CAS算法，只有在共享变量的当前值和期望值相等时，才会更新共享变量的值。

### volatile关键字的作用
- volatile关键字的作用是使变量在多个线程间可见，即一个线程修改了volatile变量的值，其他线程能够立即得知这个修改。
- 防止指令重排序，volatile关键字能禁止编译器对指令进行重排序，从而保证volatile变量的可见性。

### AQS

#### ReentrantLock
- ReentrantLock是一种可重入锁，它能够确保一个线程在获取锁的同时能够再次获取该锁，而不会出现死锁。
- ReentrantLock的锁分为公平锁和非公平锁，公平锁是指按照申请锁的顺序来获取锁，非公平锁则不保证锁的获取顺序。
- ReentrantLock的锁降级是指将持有锁的线程从偏向锁升级为轻量级锁或重量级锁。
- ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lockInterruptibly()方法可中断正在等待锁的线程。
- 利用CAS和AQS可以实现高效且正确的锁机制。

#### CountDownLatch
- CountDownLatch是一个同步工具类，它允许一个或多个线程等待，直到其他线程的操作执行完毕后再执行。
- CountDownLatch的作用是让一组线程等待直到最后一个线程完成某项操作后，再开始执行。
- CountDownLatch的计数器只能使用一次，一旦计数器值为0，则不能重置。

#### CyclicBarrier
- CyclicBarrier是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点（也可以叫同步点）时再同时执行。
- CyclicBarrier的作用是让一组线程等待至某个状态，然后一起执行。
- CyclicBarrier的计数器可以重置，所以它可以被重用。

#### Semaphore
- Semaphore是一个计数信号量，它用来控制对共享资源的访问数量。
- Semaphore的作用是控制同时访问共享资源的线程数量，Semaphore最多允许一个线程持有该Semaphore，其他线程则需要等待。
- Semaphore提供了一种限制并发线程数量的机制。


### ConcurrentHashMap
concurrenthashmap是一种线程安全的高效map集合
底层数据结构：
jdk1.7底层采用分段的数组+链表实现
jdk1.8采用的数据结构跟hashmap1.8的结构一样，数组+链表/红黑二叉树。
采用CAS+synchronized保证并发安全。
- CAS控制数组节点的添加
- synchronized只锁定当前链表或红黑二叉树的首节点，只要hash不冲突，就不会产生并发的问题，效率得到提升


## 线程池
线程池是一种用来管理线程的工具，它可以提高程序的响应速度，减少资源消耗，并且可以对线程进行管理和监控。

### 线程池的核心参数
* corepoolsize核心线程数目
* maximumpoolsize最大线程数目（核心线程+救急线程的最大数目）
* keepalivetime 生存时间-救急线程的生存时间，生存时间内没有新任务，此线程资源会释放
* unit 时间单位-救急线程的生存时间单位，如秒，毫秒等
* workqueue,当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建救急线程执行任务
* threadfactory 线程工厂，可以定制线程对象的创建，例如设置线程名字，是否是守护线程等
* handler拒绝策略当所有线程都在繁忙，workqueueue 也放满时，会触发拒绝策略。

### 你们项目哪里用到了多线程
* 批量导入：使用了线程池+countdownlatch批量把数据库中的数据导入到了
es(任意）中，避免oom
* 数据汇总：调用多个接口来汇总数据，如果所有接口（或部分接口）的没有依
赖关系，就可以使用线程池+future来提升性能
* 异步线程（线程池）:为了避免下一级方法影响上一级方法（性能考虑）,可
使用异步线程调用下一个方法（不需要下一级方法返回值）,可以提升方法响
应时间

### 谈谈你对threadlocal的理解
- 1.threadlocal可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】
,避免争用引发的线程安全问题
- 2.threadlocal同时实现了线程内的资源共享
- 3.每个线程内有一个threadlocalmap类型的成员变量，用来存储资源对象
a)调用set方法，就是以threadlocal自己作为key,资源对象作为value,放入当前线
程的 threadlocalmap 集合中
b)调用get方法，就是以threadlocal自己作为key,到当前线程中查找关联的资源值
c)调用remove方法，就是以threadlocal 自己作为key,移除当前线程关联的资源值
- 4.threadlocal内存泄漏问题
threadlocaimap 中的k@ 是弱引用，值为强引用；key会被gc释放内存，关联value
的内存并不会释放，建议主动remove释放key,value