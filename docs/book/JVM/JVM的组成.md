---
icon: pen-to-square
date: 2022-01-09
category:
  - Cherry
tag:
  - red
  - small
  - round
---

## JVM的组成主要分为三个部分： 类加载器、运行时数据区、执行引擎。

## 类加载器

类加载器是 JVM 的重要组成部分，负责加载类文件并将类文件转换为运行时数据区的运行时数据结构。 JVM 自带的类加载器有：启动类加载器、扩展类加载器、系统类加载器。

### 启动类加载器（Bootstrap Class Loader）

启动类加载器是 JVM 自带的类加载器，它负责加载 Java 运行环境中的核心类库，如 java.lang.String。启动类加载器的父类为 null，它使用 C++ 编写，是虚拟机自身的一部分。
### 扩展类加载器（Extension Class Loader）

扩展类加载器是 JVM 自带的类加载器，它负责加载 Java 运行环境的扩展类库，如 javax.swing.JButton。扩展类加载器的父类为启动类加载器。

### 系统类加载器（System Class Loader）

系统类加载器是 JVM 自带的类加载器，它负责加载用户类路径（classpath）上指定的类库，如 java.util.ArrayList。系统类加载器的父类为扩展类加载器。

## 运行时数据区

运行时数据区包括方法区、堆、虚拟机栈、程序计数器。

### 方法区（Method Area）    
是各个线程共享的内存区域
方法区是 JVM 运行时数据区的一种，用于存储类信息、常量、静态变量、即时编译器编译后的代码等。方法区的大小在 JVM 启动时确定，并且在虚拟机生命周期内不会发生垃圾回收。

### 堆（Heap）

堆是 JVM 运行时数据区的另一种，用于存储对象实例和数组。堆的大小也是在 JVM 启动时确定，并且可以动态扩展。当堆中没有足够的内存空间进行分配时，JVM 会抛出 OutOfMemoryError 异常。

### 虚拟机栈（VM Stack）

虚拟机栈是 JVM 运行时数据区的第三种，用于存储方法调用信息。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。

### 程序计数器（Program Counter Register）

程序计数器是 JVM 运行时数据区的第四种，是一个指针，指向当前线程执行的字节码指令。当线程切换时，PC 寄存器的值也会发生变化。

## 执行引擎

执行引擎是 JVM 的核心，它负责解释字节码并执行程序。JVM 实现的执行引擎有：解释器、JIT 编译器、垃圾回收器。

### 解释器（Interpreter）

解释器是 JVM 的执行引擎，它逐条解释字节码，执行程序。解释器的执行速度较慢，但它占用内存少，适用于执行较小的程序。

### JIT 编译器（Just-In-Time Compiler）

JIT 编译器是 JVM 的执行引擎，它将热点代码编译成机器码，并缓存起来，以便下次执行时直接使用。JIT 编译器的执行速度较快，但它占用内存多，适用于执行较大的程序。

### 垃圾回收器（Garbage Collector）

垃圾回收器是 JVM 的执行引擎，它负责回收不再需要的内存，以便为新对象分配内存。JVM 实现的垃圾回收器有：串行垃圾回收器、并行垃圾回收器、并发垃圾回收器。

## 堆栈的区别
- 栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储java对象
数组的的。堆会gc垃圾回收，而栈不会。
- 栈内存是线程私有的，而堆内存是线程共有的。
- 两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。
栈空间不足：java.lang.stackoverflowerror.
堆空间不足：java.lang.outofmemoryerror.

## 类加载的过程
- 加载：查找和导入class文件
- 验证：保证加载类的准确性
- 准备：为类变量分配内存并设置类变量初始值
- 解析：把类中的符号引用转换为直接引用
- 初始化：对类的静态变量，静态代码块执行初始化操作
- 使用：jvm 开始从入口方法开始执行用户的程序代码
- 卸载：当用户程序代码执行完毕后，jvm便开始销毁创建的class对象。

## 定位垃圾的算法
- 引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。当计数器为0时，说明没有任何地方引用它，则可以回收。缺点是循环引用的问题。
- 可达性分析算法：通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为“引用链”，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

## 垃圾回收的算法
- 标记-清除算法：首先标记出所有需要回收的对象，然后统一回收掉所有被标记的对象。缺点是效率不高，标记和清除两个过程效率都不高。
- 复制算法：将内存分为大小相同的两块，每次只使用其中一块，当这一块的内存用完时，就将还存活的对象复制到另一块上面，然后清理掉第一块内存。缺点是内存浪费严重。
- 标记-整理算法：标记过程和标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

## JVM调优
- 堆内存调优：-Xms：初始堆内存大小，默认为物理内存的1/64；-Xmx：最大堆内存大小，默认为物理内存的1/4；-Xmn：设置年轻代大小，默认为物理内存的1/2；-XX:NewRatio：设置年轻代和老年代的比例，默认为2；-XX:SurvivorRatio：设置新生代中Eden区与Survivor区的大小比例，默认为8；-XX:MaxTenuringThreshold：设置对象在新生代的最大年龄，默认为15；-XX:PretenureSizeThreshold：设置直接分配的最大内存，大于此值将直接在老年代分配。
- 垃圾回收器调优：-XX:+UseSerialGC：设置串行垃圾回收器；-XX:+UseParallelGC：设置并行垃圾回收器；-XX:+UseConcMarkSweepGC：设置并发标记-清除垃圾回收器；-XX:+UseG1GC：设置G1垃圾回收器。
- 其他调优：-XX:PermSize：设置永久代初始大小；-XX:MaxPermSize：设置永久代最大大小；-XX:PrintGCDetails：打印详细的GC信息；-XX:PrintGCTimeStamps：打印GC的时间戳；-XX:PrintGCDateStamps：打印GC的日期时间戳；-Xloggc：指定GC日志路径；-XX:+HeapDumpOnOutOfMemoryError：当OOM发生时，自动生成堆转储快照文件。

## Java内存泄露的排查思路
内存泄漏通常是指堆内存，通常是指一些大对象不被回收的情况
1. 通过jmap或设置jvm参数获取堆内存快照dump
2. 通过工具，visualvm去分析dump文件，visualvm可以加载离线的dump文件
3. 通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题
4. 找到对应的代码，通过阅读上下文的情况，进行修复即可

## CPU飙高排查思路
1. 使用top命令查看占用cpu的情况
2. 通过top命令查看后，可以查看是哪一个进程占用cpb较高
3. 使用ps命令查看进程中的线程信息
4. 使用jstack命令查看进程中哪些线程出现了问题，最终定位问题