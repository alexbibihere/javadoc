# 025｜如何保证接口幂等性？

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">凌晨两点，支付系统突然发出刺耳的警报——某用户账户在 0.5 秒内连续出现 5 笔 199 元的游戏充值记录。更诡异的是，数据库事务日志显示这 5 笔交易都"成功"落库，订单流水号还是同一个。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">显然这是有问题的，用户只充值了一次，但数据库却记了 5 笔交易流水，加了 5 次余额，在一些对一致性要求非常高的场景比如交易，接口没有做防重或保证幂等会引发资损问题。</font>

<font style="color:rgb(100, 100, 100);background-color:rgb(248, 246, 244);">那么，什么是接口的幂等呢？</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">幂等的定义</font>**
<font style="color:rgb(100, 100, 100);background-color:rgb(248, 246, 244);">接口幂等性，就是用户对于同一操作发起的多次请求的结果都是一致的。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">某电商平台曾遭遇黑色幽默：用户点击"支付"按钮时页面卡顿 3 秒，于是暴躁连点 5 次。结果支付网关忠实地执行了 5 次扣款，成功把价值 5000 元的手机变成"五折促销"。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这种惨案暴露了现代分布式系统的阿喀琉斯之踵——网络是不确定的，但结果必须是确定的。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">产生幂等问题的原因</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">产生幂等问题的原因是多方面的：</font>

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">网络抖动：网络波动时，TCP 重传机制可能产生重复请求。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">前端重试：用户对 loading 图标的忍耐度 ≤1.5 秒，可能会重复点击导致发送重复请求。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">消息队列：消息队列重复消费消息。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">上游请求方重试：请求方系统会有重试机制，当接口调用超时后，上游可能会一直重试请求。</font>

<font style="color:rgb(100, 100, 100);background-color:rgb(248, 246, 244);">要如何保证幂等呢？</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">Token 令牌</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">有如下几步：</font>

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">客户端预申请唯一令牌</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">服务端校验令牌后立即销毁</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">重复令牌直接拦截</font>

```typescript
// 发放令牌
public String createToken() {
    String token = UUID.randomUUID().toString();
    redisTemplate.opsForValue().set(token, "1", 5, TimeUnit.MINUTES);
    return token;
}

// 消费令牌
public boolean consumeToken(String token) {
    Long result = redisTemplate.execute(
        new DefaultRedisScript<>("if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end", Long.class),
        Collections.singletonList(token),
        "1");
    return result != null && result > 0;
}
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">优点：实现简单，天然防重</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">坑点：需要额外网络开销，令牌池可能成为性能瓶颈（建议结合本地缓存）</font>

<font style="color:rgb(100, 100, 100);background-color:rgb(248, 246, 244);">注意：token 放到 Redis 中，如果 redis 挂了咋办？</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">所以必须要做持久化，可采用 redis+数据库双写方案。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">唯一索引</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">利用数据库唯一索引来实现。</font>

```plain
ALTER TABLE payments ADD UNIQUE KEY uk_request (user_id, out_trade_no);
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这里需要注意一点，如果你的表是一个分区表（根据日期分区），因为唯一索引必须带上分区健，那么直接在原表加唯一索引的方式也就无法做到去重了。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这种情况，可以单独加个幂等表来实现：</font>

```plain
CREATE TABLE order_dempotent (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    biz_id VARCHAR(64) NOT NULL COMMENT '唯一业务ID',
    status TINYINT NOT NULL COMMENT '状态: 0处理中/1已完成',
    created_time DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    UNIQUE KEY uk_biz_id (biz_id) -- 唯一索引防重复插入
);
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">优点：原子性保障，一劳永逸，实现简单。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">缺点：比较依赖数据库，性能不及 redis 好，死锁风险随并发量指数上升</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">悲观锁</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">利用数据库锁来锁定操作记录行，比如 SELECT ... FOR UPDATE 语句，确保同一时刻只有一个事务能处理相同业务记录。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">优点：原子性保障，实现简单。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">缺点：比较依赖数据库，不适合高并发场景</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">乐观锁</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">通过版本号实现无锁并发控制</font>

```plain
UPDATE account SET balance = balance - 100, version = version + 1
WHERE user_id = 123 AND version = 5;
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">优点：无锁竞争，适合高并发</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">缺点：需要配合重试机制，ABA 问题需用时间戳解决</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">状态机</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">通过状态流转约束实现业务幂等</font>

```typescript
public enum OrderStatus {
    CREATED(1), PAID(2), FINISHED(3), CANCELED(4);

    // 状态流转矩阵
    private static final Map<Integer, Set<Integer>> transitions = Map.of(
        1, Set.of(2,4),
        2, Set.of(3,4),
        3, Collections.emptySet(),
        4, Collections.emptySet()
    );

    public static boolean canTransition(int from, int to) {
        return transitions.getOrDefault(from, Collections.emptySet()).contains(to);
    }
}
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">优势：业务强约束，防止流程错乱</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">缺点：状态维护成本高，可能产生历史包袱</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">分布式锁：Redisson</font>**
```csharp
public boolean processPayment(String lockKey, String requestId) {
    RLock lock = redisson.getLock(lockKey);
    try {
        if (lock.tryLock(0, 30, TimeUnit.SECONDS)) {
            // 业务处理
            return true;
        }
    } finally {
        if (lock.isHeldByCurrentThread()) {
            lock.unlock();
        }
    }
    return false;
}
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">优势：强一致性保障</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">缺陷：因为加锁互斥，性能损耗较大，不当使用会导致死锁发生。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">在分布式系统的世界里，幂等性不是银弹，而是盾牌。它需要我们在 CAP 定理的夹缝中寻找平衡，在代码的细节处雕刻时光。</font>



> 更新: 2025-05-15 21:33:47  
> 原文: <https://www.yuque.com/yuqueyonghue6cvnv/cxhfwd/tw3u1irb0s7scg3a>