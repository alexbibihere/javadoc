# 线上服务CPU100%问题

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">前言</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">cpu使用率100%问题，是一个让人非常头疼的问题。因为出现这类问题的原因千奇百怪，最关键的是它不是必现的，有可能是系统运行了一段时间之后，在突然的某个时间点出现问题。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">今天特地把我和同事，之前遇到过的cpu使用率100%的问题，总结了一下，给有需要的朋友一个参数。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">1 一次性获取的数据太多</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">我之前参与过餐饮相关的业务系统开发，当时我所在的团队是菜品的下游业务。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">当时菜品系统有菜品的更新，会发kafka消息，我们系统订阅该topic，就能获取到最近更新的菜品数据。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">同步菜品数据的功能，上线了一年多的时候，没有出现过什么问题。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">但在某一天下午，我们收到了大量CPU100%的报警邮件。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">追查原因之后发现，菜品系统出现了bug，我们每次获取到的都是全量的菜品数据，并非增量的数据。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">一次性获取的数据太多。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">菜品修改还是比较频繁的，也就是说我们系统，会频繁的读取和解析大量的数据，导致CPU不断飙升。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">其根本原因是频繁的full gc。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">2 kafka自动确认</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">之前我们的餐饮子系统中间，是通过消息中间件：kafka进行通信的。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">上游系统中产生了数据，写入db之后，然后把相关业务单据的id，通过kafka消息发送到broker上。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">下游系统订阅相关topic的消息，获取业务单据的id，然后调用上游系统的业务查询接口，获取相关业务数据。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">刚开始为了方便，我们消费订单消息时，kafka的确认机制，使用的是自动确认（可以少写点代码）。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">刚开始问题不大。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">随着业务的发展，用户量越来越多，每天产生的kafka消息也越来越多。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">终于开始爆出了cpu使用率100%的问题。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">后来，我们把kafka的consumer，消费消息后改成手动确认，cpu使用率100%的问题就被解决了。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">3 死循环</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">在实际工作中，可能每个开发都写过死循环的代码。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">死循环有两种：</font>

1. <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">在while、for、forEach循环中的死循环。</font>
2. <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">无限递归。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这两种情况，程序会不停的运行，使用寄存器保存循环次数或者递归深度，一直占用cpu，导致cpu使用率飙升。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">在使用JDK1.7时，还有些死循环比如多线程的环境下，往HashMap中put数据，可能会导致链表出现死循环。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">就会导致cpu不断飙高。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">4 多线程导数据</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">之前我们组有位同事做了一个供应商excel数据导入功能。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">该功能上线之后发现excel中数据只要稍微多一点，导入的耗时时间就会很长。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">因为导入供应商相关的业务逻辑有些复杂，涉及了多张表，而且是单线程中一条条按顺序导入的。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">那位同事为了提升导入数据的性能，将单线程导入，改成了使用线程池的多线程导入。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这样改造之后，excel数据导入的速度确实提升了很多。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">但上线之后，却带来另外一个问题，即：CPU使用率一路飙升。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">多线程导入数据，如果线程数量比较多，会存在大量线程上下文切换的过程，这个过程非常消耗CPU资源。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">5 同步大量文件</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">我之前参与过游戏平台的开发。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">游戏厂商的游戏接入我们平台，我们帮他们推广，赚了钱进行分成。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">每一款游戏都有一个定制化的官网，域名、图片和样式都不一样。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">当时出于性能考虑，我们当时使用了FreeMarker模板引擎，为每一款游戏都生成专门的html的静态官网。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">当时提供了十几个不同的模板，可以给游戏的运营同学选择。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">原本是没啥问题的。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">但有一次节日活动，为了增加一些喜庆的元素，在每一个模板文件中都加了一些样式。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这就需要把所有游戏的官网，用新的模板重新生成一次了。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">生成完毕之后，需要把所有的html文件，一次性同步到web服务器的指定目录下。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">由于涉及到了大量文件的同步，导致存放文件的那台应用服务器CPU飙升的很高。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">6 死锁</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">为了防止并发场景中，多个线程修改公共资源，导致的数据异常问题。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">很多时候我们会在代码中使用synchronized或者Lock加锁。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这样多个线程进入临界方法或者代码段时，需要竞争某个对象或者类的锁，只有抢到相应的锁，才能访问临界资源。其他的线程，则需要等待，拥有锁的线程释放锁，下一次可以继续竞争那把锁。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">有些业务场景中，某段代码需要线程获取多把锁，才能完成业务逻辑。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">但由于代码的bug，或者释放锁的顺序不正确，可能会引起死锁的问题。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">例如：</font>

```plain
"pool-4-thread-1"&nbsp;prio=10&nbsp;tid=0x00007f27bc11a000&nbsp;nid=0x2ae9&nbsp;waiting&nbsp;on&nbsp;condition&nbsp;[0x00007f2768ef9000]
java.lang.Thread.State:&nbsp;WAITING&nbsp;(parking)
at&nbsp;sun.misc.Unsafe.park(Native&nbsp;Method)
-&nbsp;parking&nbsp;to&nbsp;wait&nbsp;for&nbsp;&nbsp;<0x0000000090e1d048>&nbsp;(a&nbsp;java.util.concurrent.locks.ReentrantLock$FairSync)
at&nbsp;java.util.concurrent.locks.LockSupport.park(LockSupport.java:186)
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">比如线程a拥有锁c，需要获取锁d，才能完成业务逻辑。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">而刚好此时线程b拥有锁d，需要获取锁c，也能完成业务逻辑。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">线程a等待线程b释放锁，而线程b等待线程a释放锁，两个线程都持有对方需要的锁，无法主动释放，就会出现死锁问题。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">死锁会导致CPU使用率飙升。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">7 正则匹配</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">不知道你使用过正则表达式没有?</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">有时候我们为了验证用户输入的手机号、邮箱、身份证号、网页地址是否合法。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">通常情况下，会使用正则表达式，例如：</font>

```plain
^([hH][tT]{2}[pP]://|[hH][tT]{2}[pP][sS]://)(([A-Za-z0-9-~]+).)+([A-Za-z0-9-~/])+$
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这个正则表达式可以分为三个部分：</font>

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">第一部分匹配 http 和 https 协议。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">第二部分匹配 www. 字符。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">第三部分匹配许多字符。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">一个写的不好的正则表达式，就可以导致cpu使用率一下子飚升。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">其实这里导致 CPU 使用率高的关键原因就是：Java 正则表达式使用的引擎实现是NFA自动机，这种正则表达式引擎在进行字符匹配时会发生回溯。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">而一旦发生回溯，那其消耗的时间就会变得很长，有可能是几分钟，也有可能是几个小时，时间长短取决于回溯的次数和复杂度。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">我们写的正则表达式，要尽量减少回溯。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">8 耗时计算</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">有时候，我们的业务系统需要实时计算数据，比如：电商系统中需要实时计算优惠后的最终价格。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">或者需要在代码中，从一堆数据中，统计汇总出我们所需要的数据。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">如果这个实时计算或者实时统计的场景，是一个非常耗时的操作，并且该场景的请求并发量还不小。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">就可能会导致cpu飙高。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">因为实时计算需要消耗cpu资源，如果一直计算，就会一直消耗cpu资源。</font>



> 更新: 2024-05-20 17:11:48  
> 原文: <https://www.yuque.com/yuqueyonghue6cvnv/cxhfwd/hnv1lq8ul0ngh0yd>