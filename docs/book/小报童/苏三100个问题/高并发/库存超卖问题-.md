# 库存超卖问题-

### <font style="color:rgb(0, 0, 0);background-color:rgb(248, 246, 244);">前言</font>
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">相信很多同学在开发秒杀、抢购或者电商系统的时候，都或多或少遇到过“库存超卖”这个经典的坑。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">简单说就是：</font>**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">库存本来是10个，结果下单成功了15个，还负库存了！</font>**

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这还不算完，有时候订单超时、用户取消订单，库存又要退回，整个逻辑一团乱。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">老板一问：“怎么回事？”脑袋懵了，心想：</font>**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">这不是数据库自己算错了吧？</font>**

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">别慌，今天咱们从问题出发，抽丝剥茧，把库存超卖问题讲透，从原理到代码，从并发扣减到订单退回库存，争取让你看完之后，不再被这种坑困住。</font>

---

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">1. 什么是库存超卖？</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">库存超卖，就是</font>**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">库存本来不够，但系统错误地让多个用户同时买到同一个库存的商品</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">。导致这种问题的本质是：</font>**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">并发操作导致数据不一致</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">举个场景：</font>

1. <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">商品A的库存是5。</font>
2. <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">两个用户同时下单，每个人买3个。</font>
3. <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">系统同时读取库存，都看到库存是5，都判断库存够。</font>
4. <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">两个线程同时扣减库存，最终库存变成了-1。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这种情况不只是发生在秒杀场景，在任何高并发、多个用户同时下单的情况下，都可能出现。</font>

---

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">2. 库存退还的复杂场景</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">在库存超卖的基础上，还有个更头疼的问题：</font>**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">订单超时、取消订单，库存需要退还</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">。比如：</font>

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">用户在提交订单后，未及时支付，订单超时，需要释放库存。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">用户主动取消订单，系统要把占用的库存退还。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">订单部分支付失败，比如只支付了部分商品金额，库存需要退一部分。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这些问题会导致库存逻辑更复杂，因为库存扣减和退还都需要正确处理，并且要避免高并发情况下的死锁、数据错乱等问题。</font>

---

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">3. 为什么会发生库存超卖？</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">库存超卖的本质是</font>**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">并发导致的数据不一致</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">，常见的原因有以下几个：</font>

1. **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">并发读写</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">：多个线程同时读取库存值，库存尚未扣减完成就被其他线程抢占。</font>
2. **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">事务不完整</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">：数据库事务未正确使用，多个事务同时操作库存。</font>
3. **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">缺乏并发控制</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">：没有对操作加锁或加锁方式错误，导致多个线程同时操作数据库。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">让我们看个简单的代码示例：</font>

```java
public boolean buy(int goodsId) {
    // 1. 查询库存
    int stock = getStockFromDatabase(goodsId);
    if (stock > 0) {
        // 2. 扣减库存
        updateStock(goodsId, stock - 1);
        return true;
    }
    return false;
}
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">如果两个线程同时读取getStockFromDatabase(goodsId)的库存值，都会认为库存足够，最终更新库存时，数据就冲突了。</font>

---

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">4. 如何解决库存超卖问题？</font>**
**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">4.1 数据库级别控制：基于行锁</font>**

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">最简单的办法是让数据库帮我们控制并发，通过原子操作来完成库存扣减。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">关键SQL语句：</font>**

```sql
UPDATE goods 
SET stock = stock - 1 
WHERE id = #{goodsId} AND stock > 0;
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">如果库存不够，stock > 0的条件不成立，更新操作就会失败，避免了超卖。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">Java代码示例：</font>**

```java
public boolean buyGoods(int goodsId) {
    int updatedRows = jdbcTemplate.update(
        "UPDATE goods SET stock = stock - 1 WHERE id = ? AND stock > 0", goodsId);
    return updatedRows > 0;
}
```

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">优点：</font>**

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">简单直接。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">依赖数据库的行锁，性能和安全性较好。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">缺点：</font>**

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">数据库压力较大，在高并发场景下容易成为瓶颈。</font>

---

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">4.2 乐观锁：加版本号控制并发</font>**

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">在商品表中添加一个version字段，表示库存的版本号，每次更新时，检查版本号是否匹配，只有匹配时才能更新。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">表结构：</font>**

```sql
ALTER TABLE goods ADD version INT DEFAULT 0;
```

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">更新SQL：</font>**

```sql
UPDATE goods 
SET stock = stock - 1, version = version + 1 
WHERE id = #{goodsId} AND stock > 0 AND version = #{currentVersion};
```

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">代码示例：</font>**

```java
public boolean buyGoods(int goodsId) {
    Goods goods = getGoodsById(goodsId);
    int currentVersion = goods.getVersion();

    int updatedRows = jdbcTemplate.update(
        "UPDATE goods SET stock = stock - 1, version = version + 1 " +
        "WHERE id = ? AND stock > 0 AND version = ?", 
        goodsId, currentVersion);

    return updatedRows > 0;
}
```

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">优点：</font>**

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">避免了直接加锁。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">数据库并发控制更细粒度。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">缺点：</font>**

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">高并发场景下可能频繁重试，影响性能。</font>

---

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">4.3 分布式锁：适合分布式系统</font>**

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">如果系统是分布式部署的，可以使用Redis来实现分布式锁，确保同一时间只有一个线程可以操作库存。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">Redis分布式锁：</font>**

```java
public boolean buyGoods(int goodsId) {
    String lockKey = "lock:goods:" + goodsId;

    // 获取分布式锁
    boolean lockAcquired = redisTemplate.opsForValue().setIfAbsent(lockKey, "1", 10, TimeUnit.SECONDS);
    if (!lockAcquired) {
        return false; // 获取锁失败
    }

    try {
        // 查询库存并扣减
        int stock = getStockFromDatabase(goodsId);
        if (stock > 0) {
            updateStock(goodsId, stock - 1);
            return true;
        }
        return false;
    } finally {
        // 释放锁
        redisTemplate.delete(lockKey);
    }
}
```

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">优点：</font>**

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">适合分布式环境。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">锁的粒度可控。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">缺点：</font>**

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">依赖Redis，增加系统复杂性。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">如果锁释放失败，可能影响其他请求。</font>

---

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">4.4 消息队列削峰：解决高并发问题</font>**

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">高并发场景下，可以将用户的下单请求放入消息队列（比如RabbitMQ、Kafka），由后端服务按照顺序处理库存扣减。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">思路：</font>**

1. <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">用户请求先写入消息队列。</font>
2. <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">消费者从队列中取出消息，按顺序扣减库存。</font>
3. <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">库存不足时，直接丢弃后续请求。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">优点：</font>**

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">缓解数据库压力，适合高并发场景。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">确保请求按顺序处理，避免并发问题。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">缺点：</font>**

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">系统复杂度增加，需要引入消息队列。</font>

---

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">5. 如何处理订单退还库存？</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">库存退还的核心是：</font>**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">库存扣减和订单状态之间的关联</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">。最好的办法是通过“占用库存”来解决这个问题。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">核心思路：</font>**

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">每次下单时，将库存分成“占用库存”和“实际库存”。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">用户支付成功后，扣减“占用库存”。</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">用户取消订单或订单超时，将“占用库存”释放回“实际库存”。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">表结构设计：</font>**

```sql
CREATE TABLE goods (
    id INT PRIMARY KEY,
    stock INT NOT NULL,           -- 实际库存
    reserved_stock INT DEFAULT 0  -- 占用库存
);
```

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">下单操作：</font>**

```sql
UPDATE goods 
SET stock = stock - 1, reserved_stock = reserved_stock + 1 
WHERE id = #{goodsId} AND stock > 0;
```

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">支付成功：</font>**

```sql
UPDATE goods 
SET reserved_stock = reserved_stock - 1 
WHERE id = #{goodsId};
```

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">订单取消/超时：</font>**

```sql
UPDATE goods 
SET stock = stock + 1, reserved_stock = reserved_stock - 1 
WHERE id = #{goodsId};
```

---

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">6. 解决方案选择总结</font>**
1. **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">小规模系统</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">：直接用数据库行锁或乐观锁，简单高效。</font>
2. **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">中等规模系统</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">：结合分布式锁，控制并发。</font>
3. **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">高并发场景</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">：使用消息队列削峰，同时结合“占用库存”模型处理订单取消和退还逻辑。</font>

---

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">7. 总结</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">库存超卖问题本质是并发问题，解决的核心是控制并发、确保数据一致性。订单退还库存进一步增加了复杂度，但通过“占用库存”模型可以有效解决。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">**最后建议：**在设计系统时，优先考虑实际场景的并发规模，选择合适的方案，不要过度设计，但也不能忽略并发问题导致的坑。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">一步一步解决，就能让库存管理逻辑更稳定、更健壮！</font>



> 更新: 2025-05-15 19:51:30  
> 原文: <https://www.yuque.com/yuqueyonghue6cvnv/cxhfwd/wnhsg5hb394tu17r>