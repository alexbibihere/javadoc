# 数据库死锁问题-

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">前言</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">数据库死锁是一个让人头疼的问题，尤其是并发量大的系统，一旦处理不好，轻则性能下降，重则业务停滞。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">今天我们就来详细聊一聊</font>**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">数据库死锁产生的原因、优化的策略</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">，以及实际工作中的一些实践经验。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">希望这篇文章能让你对死锁问题有更清晰的认识，并能在实际工作中灵活应对。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">一、什么是数据库死锁？</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">简单来说，死锁就是多个事务互相等待对方释放资源，结果谁也不让谁，大家都被锁住了，陷入了“无解”的状态。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">打个简单的比方：你和朋友两人同时想过一条窄桥，你站在桥这头，朋友站在桥那头，结果你们都坚持对方先让，谁也不愿退让一步，这就“卡住了”。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">在数据库里，死锁就是这种“互相等待”的现象。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">二、死锁产生的根本原因</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">要解决问题，首先要知道问题是怎么来的。死锁的核心原因可以归纳为以下几点：</font>

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">1. 资源争用</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">数据库的资源有限，比如一行数据的锁、一个表的锁、一个索引的锁等。当两个事务同时需要某些资源，而这些资源又被对方占用时，就会产生死锁。</font>

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">2. 加锁顺序不一致</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">加锁的顺序不一致是最常见的死锁原因。比如：</font>

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">事务A：先锁住资源1，再锁资源2；</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">事务B：先锁住资源2，再锁资源1。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">当事务A持有资源1并等待资源2时，而事务B持有资源2并等待资源1时，就产生了死锁。</font>

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">3. 长事务占用锁资源过久</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">事务执行时间越长，持有锁的时间也就越长，这会增加其他事务进入死锁的概率。特别是在一些复杂的批量操作或长时间等待用户输入的场景下，死锁更容易发生。</font>

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">4. 索引设计不合理</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">当查询条件没有命中索引时，数据库可能会对表中大量数据加锁，从而增加死锁的概率。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">三、如何优化数据库死锁？</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">既然知道了死锁的产生原因，接下来就可以逐一对应，看看有哪些优化措施可以避免或减少死锁的发生。</font>

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">1. 统一加锁顺序</font>**
**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">核心思想：让所有事务按照相同的顺序申请资源，避免交叉等待。</font>**

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">举例说明</font>**

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">假设有两张表A和B，同时有两个事务要对这两张表进行操作：</font>

+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">事务1：更新表A -> 更新表B；</font>
+ <font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">事务2：更新表B -> 更新表A。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这种情况很容易造成死锁。优化方式是：统一加锁顺序，比如所有事务都按“先锁表A，再锁表B”的顺序操作。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">示例代码</font>**

```plain
-- 错误示例：加锁顺序不一致
BEGIN;
UPDATE A SET value = 1 WHERE id = 1;
UPDATE B SET value = 1 WHERE id = 1;
COMMIT;

BEGIN;
UPDATE B SET value = 1 WHERE id = 1;
UPDATE A SET value = 1 WHERE id = 1;
COMMIT;

-- 正确示例：加锁顺序一致
BEGIN;
UPDATE A SET value = 1 WHERE id = 1;
UPDATE B SET value = 1 WHERE id = 1;
COMMIT;

BEGIN;
UPDATE A SET value = 1 WHERE id = 1;
UPDATE B SET value = 1 WHERE id = 1;
COMMIT;
```

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">2. 将长事务拆分为短事务</font>**
**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">核心思想：减少事务占用锁的时间，降低死锁概率。</font>**

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">举例说明</font>**

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">有些小伙伴在实际工作中喜欢把一大堆操作放到一个事务里，觉得“保险一点”。比如：</font>

```sql
BEGIN;
UPDATE A SET value = 1 WHERE id = 1;
-- 这里可能还有其他复杂的操作
WAIT FOR 10 SECONDS; -- 假设这里的操作耗时很长
UPDATE B SET value = 1 WHERE id = 1;
COMMIT;
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这种长事务会持有锁资源很长时间，从而导致其他事务进入死锁。优化的方式是：</font>**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">拆分事务，把非必须的部分移到事务外执行</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">优化后：</font>

```sql
-- 事务1
BEGIN;
UPDATE A SET value = 1 WHERE id = 1;
COMMIT;

-- 事务2
BEGIN;
UPDATE B SET value = 1 WHERE id = 1;
COMMIT;
```

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">3. 合理使用索引</font>**
**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">核心思想：通过索引优化查询条件，减少锁范围。</font>**

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">举例说明</font>**

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">有些小伙伴在工作中遇到过这样的场景：表中有上百万行数据，结果查询条件没有命中索引，导致整个表被加锁。</font>

```sql
-- 查询条件没有命中索引，可能导致全表加锁
SELECT * FROM orders WHERE user_id = 123;
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">优化方式是：</font>**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">为查询字段创建索引</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">。</font>

```plain
-- 创建索引
CREATE INDEX idx_user_id ON orders(user_id);

-- 优化后的查询
SELECT * FROM orders WHERE user_id = 123;
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">命中索引后，数据库只会对相关记录加锁，避免了对全表加锁的情况，从而减少死锁概率。</font>

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">4. 减少锁的粒度</font>**
**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">核心思想：能锁行就不要锁表，尽量减少锁定范围。</font>**

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">举例说明</font>**

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">假设有一张订单表orders，我们需要更新某个用户的订单状态：</font>

```sql
-- 如果对整个表加锁，可能导致其他事务进入死锁
UPDATE orders SET status = 'completed' WHERE user_id = 123;
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">这种操作可能会对整张表加锁，优化方式是：</font>**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">限制锁的粒度</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">，只锁住某一行。</font>

```sql
-- 优化后的查询
UPDATE orders SET status = 'completed' WHERE order_id = 456;
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">通过条件精准匹配，只锁住具体的记录，减少了锁冲突的可能性。</font>

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">5. 使用乐观锁</font>**
**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">核心思想：避免传统的数据库锁机制，使用版本号控制并发。</font>**

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">举例说明</font>**

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">在一些高并发场景下，可以使用乐观锁代替数据库的行锁。常见的做法是给表增加一个version字段，每次更新时检查版本号是否匹配。</font>

```plain
-- 查询当前版本号
SELECT version FROM orders WHERE order_id = 456;

-- 更新时检查版本号
UPDATE orders
SET status = 'completed', version = version + 1
WHERE order_id = 456 AND version = 1;
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">如果版本号不匹配，说明数据已经被其他事务修改，当前事务需要重试。这种方式有效避免了死锁问题。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">四、如何快速排查和解决死锁？</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">即使我们尽量优化，也难以完全避免死锁。那么，死锁发生后如何快速排查和解决呢？</font>

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">1. 开启死锁日志</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">大部分数据库都支持开启死锁日志。通过日志可以找到死锁的根源，并针对性地优化。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">MySQL示例：</font>

```sql
-- 开启死锁日志
SHOW ENGINE INNODB STATUS;
```

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">日志中会记录导致死锁的事务和锁的相关信息，比如加锁顺序、冲突的行等。</font>

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">2. 分析慢查询</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">通过慢查询日志可以找到执行时间长、加锁范围大的SQL，针对性优化索引和SQL语句。</font>

### **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">3. 引入分布式锁</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">在分布式场景中，可以通过Redis或ZooKeeper实现分布式锁，避免多个节点同时操作同一资源导致的死锁。</font>

## **<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">五、总结</font>**
<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">数据库死锁是复杂业务中不可避免的问题，但只要理解其根本原因，并采取针对性的优化措施，就能将其影响降到最低。</font>

**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">统一加锁顺序、拆分长事务、合理使用索引、减少锁粒度、使用乐观锁</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">，这些方法都能在不同场景中发挥作用。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">另外，面对死锁时，不要慌张，排查死锁日志、分析慢查询，找到根源并逐步优化。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">只要方法得当，死锁并不可怕。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">最后，记住一句话：</font>**<font style="color:rgb(34, 34, 34);background-color:rgb(248, 246, 244);">写代码是门艺术，数据库优化更是技术与经验的结合</font>**<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">。</font>

<font style="color:rgb(51, 51, 51);background-color:rgb(248, 246, 244);">希望这些经验对你有所帮助！</font>



> 更新: 2025-05-15 19:52:05  
> 原文: <https://www.yuque.com/yuqueyonghue6cvnv/cxhfwd/gc5lv26ilz0ipagb>